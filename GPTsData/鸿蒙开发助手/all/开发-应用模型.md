# 应用模型的构成要素

更新时间: 2024-01-10 11:30

应用模型是HarmonyOS为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。有了应用模型，开发者可以基于一套统一的模型进行应用开发，使应用开发更简单、高效。

HarmonyOS应用模型的构成要素包括：

1. 应用组件
  应用组件是应用的基本组成单位，是应用的运行入口。用户启动、使用和退出应用过程中，应用组件会在不同的状态间切换，这些状态称为应用组件的生命周期。应用组件提供生命周期的回调函数，开发者通过应用组件的生命周期回调感知应用的[状态变化](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-lifecycle-0000001427902208-V3)。应用开发者在编写应用时，首先需要编写的就是应用组件，同时还需编写应用组件的生命周期回调函数，并在应用配置文件中配置相关信息。这样，操作系统在运行期间通过配置文件创建应用组件的实例，并调度它的生命周期回调函数，从而执行开发者的代码。
2. 应用进程模型
  应用进程模型定义应用进程的创建和销毁方式，以及进程间的通信方式。
3. 应用线程模型
  应用线程模型定义应用进程内线程的创建和销毁方式、主线程和UI线程的创建方式、线程间的通信方式。
4. 应用任务管理模型
  应用任务管理模型定义任务（Mission）的创建和销毁方式，以及任务与组件间的关系。HarmonyOS应用任务管理由系统应用负责，三方应用无需关注，下文不做具体介绍。
5. 应用配置文件
  应用配置文件中包含应用配置信息、应用组件信息、权限信息、开发者自定义信息等，这些信息在编译构建、分发和运行阶段分别提供给编译工具、应用市场和操作系统使用。



# 应用模型解读

更新时间: 2024-01-15 12:17

## HarmonyOS应用模型概况

随着系统的演进发展，HarmonyOS先后提供了两种应用模型：

* FA（Feature Ability）模型：HarmonyOS早期版本开始支持的模型，已经不再主推。
* Stage模型：HarmonyOS 3.1 Developer Preview版本开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。

Stage模型之所以成为主推模型，源于其设计思想。Stage模型的设计基于如下出发点。

1. 为复杂应用而设计
   * 多个应用组件共享同一个ArkTS引擎（运行ArkTS语言的虚拟机）实例，应用组件之间可以方便的共享对象和状态，同时减少复杂应用运行对内存的占用。
   * 采用面向对象的开发方式，使得复杂应用代码可读性高、易维护性好、可扩展性强。
2. 支持多设备和多窗口形态
   应用组件管理和窗口管理在架构层面解耦：
   * 便于系统对应用组件进行裁剪（无屏设备可裁剪窗口）。
   * 便于系统扩展窗口形态。
   * 在多设备（如桌面设备和移动设备）上，应用组件可使用同一套生命周期。
3. 平衡应用能力和系统管控成本
   Stage模型重新定义应用能力的边界，平衡应用能力和系统管控成本。
   * 提供特定场景（如卡片、输入法）的应用组件，以便满足更多的使用场景。
   * 规范化后台进程管理：为保障用户体验，Stage模型对后台应用进程进行了有序治理，应用程序不能随意驻留在后台，同时应用后台行为受到严格管理，防止恶意应用行为。

## 通过对比认识FA模型与Stage模型

 Stage模型与FA模型最大的区别在于 ：Stage模型中，多个应用组件共享同一个ArkTS引擎实例；而FA模型中，每个应用组件独享一个ArkTS引擎实例。因此在Stage模型中，应用组件之间可以方便的共享对象和状态，同时减少复杂应用运行对内存的占用。Stage模型作为主推的应用模型，开发者通过它能够更加便利地开发出分布式场景下的复杂应用。

可通过如下对比表格了解两种模型的整体概况。

表1 FA模型与Stage模型差异概览

| 项目                   | FA模型                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Stage模型                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 应用组件     | 1. 组件分类![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183807.29131481081492634354539404250632:50001231000000:2800:7B471847779A8EBF8FB498BB6BBE1458CD017B0B9A41D6D29EE9EC6C9130C4DE.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大") - PageAbility组件：包含UI界面，提供展示UI的能力。详细介绍请参见[PageAbility组件概述](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/pageability-overview-0000001478340893-V3)。- ServiceAbility组件：提供后台服务的能力，无UI界面。详细介绍请参见[ServiceAbility组件概述](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/serviceability-overview-0000001427584628-V3)。- DataAbility组件：提供数据分享的能力，无UI界面。详细介绍请参见[DataAbility组件概述](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/dataability-overview-0000001428061508-V3)。2. 开发方式通过导出匿名对象、固定入口文件的方式指定应用组件。开发者无法进行派生，不利于扩展能力。 | 1. 组件分类![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183807.63076002401067021809337070382294:50001231000000:2800:4490D13AADCABFA0BEEF23041D93F4B3FC102D56869AAB6BC574775C54D1E2EF.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大") - UIAbility组件：包含UI界面，提供展示UI的能力，主要用于和用户交互。详细介绍请参见[UIAbility组件概述](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-overview-0000001477980929-V3)。- ExtensionAbility组件：提供特定场景（如卡片、输入法）的扩展能力，满足更多的使用场景。详细介绍请参见[ExtensionAbility组件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/4_3extensionability_u7ec4_u4ef6-0000001478340873-V3)。2. 开发方式采用面向对象的方式，将应用组件以类接口的形式开放给开发者，可以进行派生，利于扩展能力。 |
| 进程模型     | 有两类进程：1. 主进程2. 渲染进程详细介绍请参见[进程模型](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/process-model-fa-0000001478181185-V3)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | 有三类进程：1. 主进程2. ExtensionAbility进程3. 渲染进程详细介绍请参见[进程模型](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/process-model-stage-0000001428061488-V3)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 线程模型     | 1. ArkTS引擎实例的创建一个进程可以运行多个应用组件实例，每个应用组件实例运行在一个单独的ArkTS引擎实例中。2. 线程模型每个ArkTS引擎实例都在一个单独线程（非主线程）上创建，主线程没有ArkTS引擎实例。3. 进程内对象共享：不支持。详细介绍请参见[线程模型](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/thread-model-fa-0000001427902248-V3)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | 1. ArkTS引擎实例的创建一个进程可以运行多个应用组件实例，所有应用组件实例共享一个ArkTS引擎实例。2. 线程模型ArkTS引擎实例在主线程上创建。3. 进程内对象共享：支持。详细介绍请参见[线程模型](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/thread-model-stage-0000001428061492-V3)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 应用配置文件 | 使用config.json描述应用信息、HAP信息和应用组件信息。详细介绍请参见[应用配置文件概述（FA模型）](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-configuration-file-overview-fa-0000001478340857-V3)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | 使用app.json5描述应用信息，module.json5描述HAP信息、应用组件信息。详细介绍请参见[应用配置文件概述（Stage模型）](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-configuration-file-overview-stage-0000001428061460-V3)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |



# Stage模型开发概述

更新时间: 2024-01-15 12:17

## 基本概念

下图展示了Stage模型中的基本概念。

图1 Stage模型概念图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183808.05512713618873359169037194692218:50001231000000:2800:D9354C1CE456CD407E4B4F43B82950F7BE0B6E19F6DA2D8B3A321DCF95F5615A.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

* [UIAbility组件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-overview-0000001477980929-V3)和ExtensionAbility组件
  Stage模型提供UIAbility和ExtensionAbility两种类型的组件，这两种组件都有具体的类承载，支持面向对象的开发方式。
  * UIAbility组件是一种包含UI界面的应用组件，主要用于和用户交互。例如，图库类应用可以在UIAbility组件中展示图片瀑布流，在用户选择某个图片后，在新的页面中展示图片的详细内容。同时用户可以通过返回键返回到瀑布流页面。UIAbility的生命周期只包含创建/销毁/前台/后台等状态，与显示相关的状态通过WindowStage的事件暴露给开发者。
  * ExtensionAbility组件是一种面向特定场景的应用组件。
* [WindowStage](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-window-stage-0000001427584712-V3)
  每个UIAbility类实例都会与一个WindowStage类实例绑定，该类提供了应用进程内窗口管理器的作用。它包含一个主窗口。也就是说UIAbility通过WindowStage持有了一个窗口，该窗口为ArkUI提供了绘制区域。
* [Context](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-context-stage-0000001427744560-V3)
  在Stage模型上，Context及其派生类向开发者提供在运行期可以调用的各种能力。UIAbility组件和各种ExtensionAbility派生类都有各自不同的Context类，他们都继承自基类Context，但是各自又根据所属组件，提供不同的能力。
* [AbilityStage](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/abilitystage-0000001427584604-V3)
  每个Entry类型或者Feature类型的HAP在运行期都有一个AbilityStage类实例，当HAP中的代码首次被加载到进程中的时候，系统会先创建AbilityStage实例。每个在该HAP中定义的UIAbility类，在实例化后都会与该实例产生关联。开发者可以使用AbilityStage获取该HAP中UIAbility实例的运行时信息。

## 开发流程

基于Stage模型开发应用时，在应用模型部分，涉及如下开发过程。

表1 Stage模型开发流程

| 任务         | 简介                                                                         | 相关指导                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| :----------- | :--------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 应用组件开发 | 本章节介绍了如何使用Stage模型的UIAbility组件和ExtensionAbility组件开发应用。 | -[应用/组件级配置](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-component-configuration-stage-0000001478340869-V3)- [UIAbility组件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-overview-0000001477980929-V3)- [ExtensionAbility组件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/4_3extensionability_u7ec4_u4ef6-0000001478340873-V3)- [AbilityStage组件容器](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/abilitystage-0000001427584604-V3)- [应用上下文Context](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-context-stage-0000001427744560-V3) |
| 了解进程模型 | 本章节介绍了Stage模型的进程模型以及几种常用的进程间通信方式。                | -[公共事件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/common-event-overview-0000001427744568-V3)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 了解线程模型 | 本章节介绍了Stage模型的线程模型以及几种常用的线程间通信方式。                | -[Emitter](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/itc-with-emitter-0000001427584616-V3)- [Worker](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/itc-with-worker-0000001427744572-V3)                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 应用配置文件 | 本章节介绍Stage模型中应用配置文件的开发要求。                                | [Stage模型应用配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-configuration-file-overview-stage-0000001428061460-V3)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |



# 应用/组件级配置

更新时间: 2024-01-15 12:17

在开发应用时，需要配置应用的一些标签，例如应用的包名、图标等标识特征的属性。本文描述了在开发应用需要配置的一些关键标签。图标和标签通常一起配置，可以分为应用图标、应用标签和入口图标、入口标签，分别对应[app.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/app-configuration-file-0000001427584584-V3)和[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)文件中的icon和label标签。应用图标和标签是在设置应用中使用，例如设置应用中的应用列表。入口图标是应用安装完成后在设备桌面上显示出来的，如图一所示。入口图标是以[UIAbility](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-overview-0000001477980929-V3)为粒度，支持同一个应用存在多个入口图标和标签，点击后进入对应的UIAbility界面。

图1 应用图标和标签

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183808.47800877830405254968295228528543:50001231000000:2800:F91F650D8625C46F4C013F689E347E890ECC2873F208A4CC729F550117942BC4.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

* 应用包名配置
  应用需要在工程的AppScope目录下的[app.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/app-configuration-file-0000001427584584-V3)中配置bundleName标签，该标签用于标识应用的唯一性。推荐采用反域名形式命名（如com.example.demo，建议第一级为域名后缀com，第二级为厂商/个人名，第三级为应用名，也可以多级）。
* 应用图标和标签配置
  Stage模型的应用需要配置应用图标和应用标签。应用图标和标签是在设置应用中使用，例如设置应用中的应用列表，会显示出对应的图标和标签。
  应用图标需要在工程的AppScope目录下的[app.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/app-configuration-file-0000001427584584-V3)中配置icon标签。应用图标需配置为图片的资源索引，配置完成后，该图片即为应用的图标。
  应用标签需要在工程的AppScope模块下的[app.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/app-configuration-file-0000001427584584-V3)中配置label标签。标识应用对用户显示的名称，需要配置为字符串资源的索引。
```
  {
    "app": {
      "icon": "$media:app_icon",
      "label": "$string:app_name"
      // ...
    }
  }
```
* 入口图标和标签配置
  Stage模型支持对组件配置入口图标和入口标签。入口图标和入口标签会显示在桌面上。
  入口图标需要在[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)中配置，在abilities标签下面有icon标签。例如希望在桌面上显示该UIAbility的图标，则需要在skills标签下面的entities中添加"entity.system.home"、actions中添加"action.system.home"。同一个应用有多个UIAbility配置上述字段时，桌面上会显示出多个图标，分别对应各自的UIAbility。
```
{
  "module": {
    // ...
    "abilities": [
      {
        // $开头的为资源值
        "icon": "$media:icon",
        "label": "$string:EntryAbility_label",
        "skills": [
          {
            "entities": [
              "entity.system.home"
            ],
            "actions": [
              "action.system.home"
            ]
          }
        ],
      }
    ]
  }
}
```
* 应用版本声明配置
  应用版本声明需要在工程的AppScope目录下的[app.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/app-configuration-file-0000001427584584-V3)中配置versionCode标签和versionName标签。versionCode用于标识应用的版本号，该标签值为32位非负整数。此数字仅用于确定某个版本是否比另一个版本更新，数值越大表示版本越高。versionName标签标识版本号的文字描述。
* Module支持的设备类型配置
  Module支持的设备类型需要在[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)中配置deviceTypes标签，如果deviceTypes标签中添加了某种设备，则表明当前的Module支持在该设备上运行。
* Module权限配置
  Module访问系统或其他应用受保护部分所需的权限信息需要在[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)中配置requestPermission标签。该标签用于声明需要申请权限的名称、申请权限的原因以及权限使用的场景。



# UIAbility组件概述

更新时间: 2024-01-15 11:54

## 概述

UIAbility组件是一种包含UI界面的应用组件，主要用于和用户交互。

UIAbility组件是系统调度的基本单元，为应用提供绘制界面的窗口；一个UIAbility组件中可以通过多个页面来实现一个功能模块。每一个UIAbility组件实例，都对应于一个最近任务列表中的任务。

## 声明配置

为使应用能够正常使用UIAbility，需要在[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)的[abilities标签](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3#ZH-CN_TOPIC_0000001573929365__abilities%E6%A0%87%E7%AD%BE)中声明UIAbility的名称、入口、标签等相关信息。

```
{
  "module": {
    // ...
    "abilities": [
      {
        "name": "EntryAbility", // UIAbility组件的名称
        "srcEntrance": "./ets/entryability/EntryAbility.ts", // UIAbility组件的代码路径
        "description": "$string:EntryAbility_desc", // UIAbility组件的描述信息
        "icon": "$media:icon", // UIAbility组件的图标
        "label": "$string:EntryAbility_label", // UIAbility组件的标签
        "startWindowIcon": "$media:icon", // UIAbility组件启动页面图标资源文件的索引
        "startWindowBackground": "$color:start_window_background", // UIAbility组件启动页面背景颜色资源文件的索引
        // ...
      }
    ]
  }
}
```



# UIAbility组件生命周期

更新时间: 2024-01-10 11:31

## 概述

当用户打开、切换和返回到对应应用时，应用中的UIAbility实例会在其生命周期的不同状态之间转换。UIAbility类提供了一系列回调，通过这些回调可以知道当前UIAbility实例的某个状态发生改变，会经过UIAbility实例的创建和销毁，或者UIAbility实例发生了前后台的状态切换。

UIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，如下图所示。

图1 UIAbility生命周期状态

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183809.66913538672056367927358216578430:50001231000000:2800:64A9E18EEE751E39F95C0B481D31F0F5AA10190AD5C692F7630C51FFDECA7E6F.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

## 生命周期状态说明

### Create状态

Create状态为在应用加载过程中，UIAbility实例创建完成时触发，系统会调用onCreate()回调。可以在该回调中进行应用初始化操作，例如变量定义资源加载等，用于后续的UI界面展示。

```
import UIAbility from '@ohos.app.ability.UIAbility';
import Window from '@ohos.window';

export default class EntryAbility extends UIAbility {
    onCreate(want, launchParam) {
        // 应用初始化
    }
    // ...
}
```

### WindowStageCreate和WindowStageDestroy状态

UIAbility实例创建完成之后，在进入Foreground之前，系统会创建一个WindowStage。WindowStage创建完成后会进入onWindowStageCreate()回调，可以在该回调中设置UI界面加载、设置WindowStage的事件订阅。

图2 WindowStageCreate和WindowStageDestroy状态

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183809.19031159446360567182369463370403:50001231000000:2800:61F91FF60D503DB3F77037CBA61DE37080FD2F03DE5A602ADBC6C1067DB81338.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

在onWindowStageCreate()回调中通过loadContent()方法设置应用要加载的页面并根据需要订阅WindowStage的[事件](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-window-0000001477981397-V3#ZH-CN_TOPIC_0000001573929313__windowstageeventtype9)（获焦/失焦、可见/不可见）。

```
import UIAbility from '@ohos.app.ability.UIAbility';
import Window from '@ohos.window';

export default class EntryAbility extends UIAbility {
    onWindowStageCreate(windowStage: Window.WindowStage) {
        // 设置WindowStage的事件订阅（获焦/失焦、可见/不可见）

        // 设置UI界面加载
        windowStage.loadContent('pages/Index', (err, data) => {
            // ...
        });
    }
}
```

说明

WindowStage的相关使用请参见[窗口开发指导](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-window-stage-0000001427584712-V3)。

对应于onWindowStageCreate()回调。在UIAbility实例销毁之前，则会先进入onWindowStageDestroy()回调，可以在该回调中释放UI界面资源。例如在onWindowStageDestroy()中注销获焦/失焦等WindowStage事件。

```
import UIAbility from '@ohos.app.ability.UIAbility';
import Window from '@ohos.window';

export default class EntryAbility extends UIAbility {
    // ...

    onWindowStageDestroy() {
        // 释放UI界面资源
    }
}
```

### Foreground和Background状态

Foreground和Background状态分别在UIAbility实例切换至前台和切换至后台时触发，对应于onForeground()回调和onBackground()回调。

onForeground()回调，在UIAbility的UI界面可见之前，如UIAbility切换至前台时触发。可以在onForeground()回调中申请系统需要的资源，或者重新申请在onBackground()中释放的资源。

onBackground()回调，在UIAbility的UI界面完全不可见之后，如UIAbility切换至后台时候触发。可以在onBackground()回调中释放UI界面不可见时无用的资源，或者在此回调中执行较为耗时的操作，例如状态保存等。

例如应用在使用过程中需要使用用户定位时，假设应用已获得用户的定位权限授权。在UI界面显示之前，可以在onForeground()回调中开启定位功能，从而获取到当前的位置信息。

当应用切换到后台状态，可以在onBackground()回调中停止定位功能，以节省系统的资源消耗。

```
import UIAbility from '@ohos.app.ability.UIAbility';

export default class EntryAbility extends UIAbility {
    onForeground() {
        // 申请系统需要的资源，或者重新申请在onBackground中释放的资源
    }

    onBackground() {
        // 释放UI界面不可见时无用的资源，或者在此回调中执行较为耗时的操作
        // 例如状态保存等
    }
}
```

### Destroy状态

Destroy状态在UIAbility实例销毁时触发。可以在onDestroy()回调中进行系统资源的释放、数据的保存等操作。

例如调用terminateSelf()方法停止当前UIAbility实例，从而完成UIAbility实例的销毁；或者用户使用最近任务列表关闭该UIAbility实例，完成UIAbility的销毁。

```
import UIAbility from '@ohos.app.ability.UIAbility';
import Window from '@ohos.window';

export default class EntryAbility extends UIAbility {
    onDestroy() {
        // 系统资源的释放、数据的保存等
    }
}
```



# UIAbility组件启动模式

更新时间: 2024-01-10 11:31

UIAbility的启动模式是指UIAbility实例在启动时的不同呈现状态。针对不同的业务场景，系统提供了三种启动模式：

* [singleton（单实例模式）](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-launch-type-0000001428061476-V3#ZH-CN_TOPIC_0000001523489150__singleton%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F)
* [multiton（多实例模式）](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-launch-type-0000001428061476-V3#ZH-CN_TOPIC_0000001523489150__standard%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F)
* [specified（指定实例模式）](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-launch-type-0000001428061476-V3#ZH-CN_TOPIC_0000001523489150__specified%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F)

## singleton启动模式

singleton启动模式为单实例模式，也是默认情况下的启动模式。

每次调用startAbility()方法时，如果应用进程中该类型的UIAbility实例已经存在，则复用系统中的UIAbility实例。系统中只存在唯一一个该UIAbility实例，即在最近任务列表中只存在一个该类型的UIAbility实例。

图1 单实例模式演示效果

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231204103813.00297545571341265281124340124509:50001231000000:2800:3DCC6EB95C19EA527445BD4E7D91457069F9DAD1DB1E1BEDD1AAFE4AD9372F4D.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

说明

应用的UIAbility实例已创建，该UIAbility配置为单实例模式，再次调用startAbility()方法启动该UIAbility实例，此时只会进入该UIAbility的onNewWant()回调，不会进入其onCreate()和onWindowStageCreate()生命周期回调。

如果需要使用singleton启动模式，在[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)中的"launchType"字段配置为"singleton"即可。

```
{
  "module": {
    // ...
    "abilities": [
      {
        "launchType": "singleton",
        // ...
      }
    ]
  }
}
```

## multiton启动模式

multiton启动模式为多实例模式，每次调用startAbility()方法时，都会在应用进程中创建一个新的该类型UIAbility实例。即在最近任务列表中可以看到有多个该类型的UIAbility实例。这种情况下可以将UIAbility配置为multiton（多实例模式）。

图2 多实例模式演示效果

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231204103813.10599470521323982699022457348898:50001231000000:2800:A9DF4780F0C3E1BC1085A689441400880F1E6C52B818A7CDE88D12A699CF0E02.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

multiton启动模式的开发使用，在[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)中的"launchType"字段配置为"multiton"即可。

```
{
  "module": {
    // ...
    "abilities": [
      {
        "launchType": "multiton",
        // ...
      }
    ]
  }
}
```

## specified启动模式

specified启动模式为指定实例模式，针对一些特殊场景使用（例如文档应用中每次新建文档希望都能新建一个文档实例，重复打开一个已保存的文档希望打开的都是同一个文档实例）。

在UIAbility实例创建之前，允许开发者为该实例创建一个唯一的字符串Key，创建的UIAbility实例绑定Key之后，后续每次调用startAbility()方法时，都会询问应用使用哪个Key对应的UIAbility实例来响应startAbility()请求。运行时由UIAbility内部业务决定是否创建多实例，如果匹配有该UIAbility实例的Key，则直接拉起与之绑定的UIAbility实例，否则创建一个新的UIAbility实例。

图3 指定实例模式演示效果

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231204103813.40705075326359333177574957806731:50001231000000:2800:30202926B0A3556615739030EEF92C59D69886F3CBA39712351C4C06D7DB3FF7.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

说明

应用的UIAbility实例已创建，该UIAbility配置为指定实例模式，再次调用startAbility()方法启动该UIAbility实例，且[AbilityStage](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/abilitystage-0000001427584604-V3)的[onAcceptWant()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageonacceptwant)回调匹配到一个已创建的UIAbility实例。此时，再次启动该UIAbility时，只会进入该UIAbility的[onNewWant()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-uiability-0000001493584184-V3#ZH-CN_TOPIC_0000001523808838__abilityonnewwant)回调，不会进入其onCreate()和onWindowStageCreate()生命周期回调。

例如有两个UIAbility：EntryAbility和FuncAbility，FuncAbility配置为specified启动模式，需要从EntryAbility的页面中启动FuncAbility。

1. 在FuncAbility中，将[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)的"launchType"字段配置为"specified"。

```
{
  "module": {
    // ...
    "abilities": [
      {
        "launchType": "specified",
        // ...
      }
    ]
  }
}
```
2. 在EntryAbility中，调用startAbility()方法时，在want参数中，增加一个自定义参数来区别UIAbility实例，例如增加一个"instanceKey"自定义参数。

```
// 在启动指定实例模式的UIAbility时，给每一个UIAbility实例配置一个独立的Key标识
// 例如在文档使用场景中，可以用文档路径作为Key标识
function getInstance() {
    // ...
}

let want = {
    deviceId: '', // deviceId为空表示本设备
    bundleName: 'com.example.myapplication',
    abilityName: 'FuncAbility',
    moduleName: 'module1', // moduleName非必选
    parameters: { // 自定义信息
        instanceKey: getInstance(),
    },
}
// context为调用方UIAbility的AbilityContext
this.context.startAbility(want).then(() => {
    // ...
}).catch((err) => {
    // ...
})
```
3. 由于FuncAbility的启动模式配置为了指定实例启动模式，在FuncAbility启动之前，会先进入其对应的AbilityStage的[onAcceptWant()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageonacceptwant)生命周期回调中，解析传入的want参数，获取"instanceKey"自定义参数。根据业务需要通过AbilityStage的[onAcceptWant()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageonacceptwant)生命周期回调返回一个字符串Key标识。如果返回的Key对应一个已启动的UIAbility，则会将之前的UIAbility拉回前台并获焦，而不创建新的实例，否则创建新的实例并启动。

```
import AbilityStage from '@ohos.app.ability.AbilityStage';

export default class MyAbilityStage extends AbilityStage {
    onAcceptWant(want): string {
        // 在被调用方的AbilityStage中，针对启动模式为specified的UIAbility返回一个UIAbility实例对应的一个Key值
        // 当前示例指的是module1 Module的FuncAbility
        if (want.abilityName === 'FuncAbility') {
            // 返回的字符串Key标识为自定义拼接的字符串内容
            return `ControlModule_EntryAbilityInstance_${want.parameters.instanceKey}`;
        }

        return '';
    }
}
```

  例如在文档应用中，可以对不同的文档实例内容绑定不同的Key值。当每次新建文档的时候，可以传入不同的新Key值（如可以将文件的路径作为一个Key标识），此时AbilityStage中启动UIAbility时都会创建一个新的UIAbility实例；当新建的文档保存之后，回到桌面，或者新打开一个已保存的文档，回到桌面，此时再次打开该已保存的文档，此时AbilityStage中再次启动该UIAbility时，打开的仍然是之前原来已保存的文档界面。

  以如下步骤所示进行举例说明。

  1. 打开文件A，对应启动一个新的UIAbility实例，例如启动"UIAbility实例1"。
  2. 在最近任务列表中关闭文件A的进程，此时UIAbility实例1被销毁，回到桌面，再次打开文件A，此时对应启动一个新的UIAbility实例，例如启动"UIAbility实例2"。
  3. 回到桌面，打开文件B，此时对应启动一个新的UIAbility实例，例如启动"UIAbility实例3"。
  4. 回到桌面，再次打开文件A，此时对应启动的还是之前的"UIAbility实例2"。



# UIAbility组件基本用法

更新时间: 2024-01-15 12:18

UIAbility组件的基本用法包括：指定UIAbility的启动页面以及获取UIAbility的上下文[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)。

## 指定UIAbility的启动页面

应用中的UIAbility在启动过程中，需要指定启动页面，否则应用启动后会因为没有默认加载页面而导致白屏。可以在UIAbility的onWindowStageCreate()生命周期回调中，通过[WindowStage](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-window-0000001477981397-V3#ZH-CN_TOPIC_0000001573929313__windowstage9)对象的loadContent()方法设置启动页面。

```
import UIAbility from '@ohos.app.ability.UIAbility';
import Window from '@ohos.window';

export default class EntryAbility extends UIAbility {
    onWindowStageCreate(windowStage: Window.WindowStage) {
        // Main window is created, set main page for this ability
        windowStage.loadContent('pages/Index', (err, data) => {
            // ...
        });
    }

    // ...
}
```

说明

在DevEco Studio中创建的UIAbility中，该UIAbility实例默认会加载Index页面，根据需要将Index页面路径替换为需要的页面路径即可。

## 获取UIAbility的上下文信息

UIAbility类拥有自身的上下文信息，该信息为[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)类的实例，[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)类拥有abilityInfo、currentHapModuleInfo等属性。通过UIAbilityContext可以获取UIAbility的相关配置信息，如包代码路径、Bundle名称、Ability名称和应用程序需要的环境状态等属性信息，以及可以获取操作UIAbility实例的方法（如startAbility()、connectServiceExtensionAbility()、terminateSelf()等）。

* 在UIAbility中可以通过this.context获取UIAbility实例的上下文信息。

```
import UIAbility from '@ohos.app.ability.UIAbility';

export default class EntryAbility extends UIAbility {
    onCreate(want, launchParam) {
        // 获取UIAbility实例的上下文
        let context = this.context;

        // ...
    }
}
```
* 在页面中获取UIAbility实例的上下文信息，包括导入依赖资源context模块和在组件中定义一个context变量两个部分。

```
import common from '@ohos.app.ability.common';

@Entry
@Component
struct Index {
  private context = getContext(this) as common.UIAbilityContext;

  startAbilityTest() {
    let want = {
      // Want参数信息
    };
    this.context.startAbility(want);
  }

  // 页面展示
  build() {
    // ...
  }
}
```

  也可以在导入依赖资源context模块后，在具体使用[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)前进行变量定义。

```
import common from '@ohos.app.ability.common';

@Entry
@Component
struct Index {

  startAbilityTest() {
    let context = getContext(this) as common.UIAbilityContext;
    let want = {
      // Want参数信息
    };
    context.startAbility(want);
  }

  // 页面展示
  build() {
    // ...
  }
}
```



# UIAbility组件与UI的数据同步

更新时间: 2024-01-10 11:33

基于HarmonyOS的应用模型，可以通过以下两种方式来实现UIAbility组件与UI之间的数据同步。

* [使用EventHub进行数据通信](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-data-sync-with-ui-0000001427744556-V3#ZH-CN_TOPIC_0000001574088345__%E4%BD%BF%E7%94%A8eventhub%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1)：基于发布订阅模式来实现，事件需要先订阅后发布，订阅者收到消息后进行处理。
* [使用globalThis进行数据同步](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-data-sync-with-ui-0000001427744556-V3#ZH-CN_TOPIC_0000001574088345__%E4%BD%BF%E7%94%A8globalthis%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5)：ArkTS引擎实例内部的一个全局对象，在ArkTS引擎实例内部都能访问。
* [使用AppStorage/LocalStorage进行数据同步](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-data-sync-with-ui-0000001427744556-V3#section1926741133818)：ArkUI提供了AppStorage和LocalStorage两种应用级别的状态管理方案，可用于实现应用级别和UIAbility级别的数据同步。

## 使用EventHub进行数据通信

EventHub提供了UIAbility组件/ExtensionAbility组件级别的事件机制，以UIAbility组件/ExtensionAbility组件为中心提供了订阅、取消订阅和触发事件的数据通信能力。接口说明请参见[EventHub](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-eventhub-0000001477981377-V3)。

在使用EventHub之前，首先需要获取EventHub对象。[基类Context](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-context-stage-0000001427744560-V3)提供了EventHub对象，本章节以使用EventHub实现UIAbility与UI之间的数据通信为例进行说明。

1. 在UIAbility中调用eventHub.on()方法注册一个自定义事件“event1”，eventHub.on()有如下两种调用方式，使用其中一种即可。
```
import UIAbility from '@ohos.app.ability.UIAbility';

const TAG: string = '[Example].[Entry].[EntryAbility]';

export default class EntryAbility extends UIAbility {
    func1(...data) {
        // 触发事件，完成相应的业务操作
        console.info(TAG, '1. ' + JSON.stringify(data));
    }

    onCreate(want, launch) {
        // 获取eventHub
        let eventhub = this.context.eventHub;
        // 执行订阅操作
        eventhub.on('event1', this.func1);
        eventhub.on('event1', (...data) => {
            // 触发事件，完成相应的业务操作
            console.info(TAG, '2. ' + JSON.stringify(data));
        });
    }
}
```
2. 在UI界面中通过eventHub.emit()方法触发该事件，在触发事件的同时，根据需要传入参数信息。
```
import common from '@ohos.app.ability.common';

@Entry
@Component
struct Index {
  private context = getContext(this) as common.UIAbilityContext;

  eventHubFunc() {
    // 不带参数触发自定义“event1”事件
    this.context.eventHub.emit('event1');
    // 带1个参数触发自定义“event1”事件
    this.context.eventHub.emit('event1', 1);
    // 带2个参数触发自定义“event1”事件
    this.context.eventHub.emit('event1', 2, 'test');
    // 开发者可以根据实际的业务场景设计事件传递的参数
  }

  // 页面展示
  build() {
    // ...
  }
}
```
3. 在UIAbility的注册事件回调中可以得到对应的触发事件结果，运行日志结果如下所示。
```
[]

[1]

[2,'test']
```
4. 在自定义事件“event1”使用完成后，可以根据需要调用eventHub.off()方法取消该事件的订阅。
```
// context为UIAbility实例的AbilityContext
this.context.eventHub.off('event1');
```

## 使用globalThis进行数据同步

globalThis是ArkTS引擎实例内部的一个全局对象，引擎内部的UIAbility/ExtensionAbility/Page都可以使用，因此可以使用globalThis全局对象进行数据同步。

图1 使用globalThis进行数据同步

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240103115011.67394958096994441918034372813121:50001231000000:2800:55AD4F2749B2FC57636E1290B4FCC1AB0B1116684C13D9736AFA23CC6D4C38CD.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

如上图所示，下面来具体介绍globalThis的使用：

* [UIAbility和Page之间使用globalThis](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-data-sync-with-ui-0000001427744556-V3#ZH-CN_TOPIC_0000001574088345__uiability%E5%92%8Cpage%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8globalthis)
* [UIAbility和UIAbility之间使用globalThis](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-data-sync-with-ui-0000001427744556-V3#ZH-CN_TOPIC_0000001574088345__uiability%E5%92%8Cuiability%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8globalthis)
* [globalThis使用的注意事项](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-data-sync-with-ui-0000001427744556-V3#ZH-CN_TOPIC_0000001574088345__globalthis%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)

### UIAbility和Page之间使用globalThis

globalThis为[ArkTS引擎实例](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/thread-model-stage-0000001428061492-V3)下的全局对象，可以通过globalThis绑定属性/方法来进行UIAbility组件与UI的数据同步。例如在UIAbility组件中绑定want参数，即可在UIAbility对应的UI界面上使用want参数信息。

1. 调用startAbility()方法启动一个UIAbility实例时，被启动的UIAbility创建完成后会进入onCreate()生命周期回调，且在onCreate()生命周期回调中能够接受到传递过来的want参数，可以将want参数绑定到globalThis上。
```
import UIAbility from '@ohos.app.ability.UIAbility'

export default class EntryAbility extends UIAbility {
    onCreate(want, launch) {
        globalThis.entryAbilityWant = want;
        // ...
    }

    // ...
}
```
2. 在UI界面中即可通过globalThis获取到want参数信息。
```
let entryAbilityWant;

@Entry
@Component
struct Index {
  aboutToAppear() {
    entryAbilityWant = globalThis.entryAbilityWant;
  }

  // 页面展示
  build() {
    // ...
  }
}
```

### UIAbility和UIAbility之间使用globalThis

同一个应用中UIAbility和UIAbility之间的数据传递，可以通过将数据绑定到全局变量globalThis上进行同步，如在AbilityA中将数据保存在globalThis，然后跳转到AbilityB中取得该数据：

1. AbilityA中保存数据一个字符串数据并挂载到globalThis上。
```
import UIAbility from '@ohos.app.ability.UIAbility'

export default class AbilityA extends UIAbility {
    onCreate(want, launch) {
        globalThis.entryAbilityStr = 'AbilityA'; // AbilityA存放字符串“AbilityA”到globalThis
        // ...
    }
}
```
2. AbilityB中获取对应的数据。
```
import UIAbility from '@ohos.app.ability.UIAbility'

export default class AbilityB extends UIAbility {
    onCreate(want, launch) {
        // AbilityB从globalThis读取name并输出
        console.info('name from entryAbilityStr: ' + globalThis.entryAbilityStr);
        // ...
    }
}
```

### globalThis使用的注意事项

图2 globalThis注意事项

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240103115011.93694631415256060283753496049151:50001231000000:2800:D382C235F4AC5B670D647E0A5BCEF0749811F161F9F5E75A886FC55ED23958A8.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

* Stage模型下进程内的UIAbility组件共享ArkTS引擎实例，使用globalThis时需要避免存放相同名称的对象。例如AbilityA和AbilityB可以使用globalThis共享数据，在存放相同名称的对象时，先存放的对象会被后存放的对象覆盖。
* FA模型因为每个UIAbility组件之间引擎隔离，不会存在该问题。
* 对于绑定在globalThis上的对象，其生命周期与ArkTS虚拟机实例相同，建议在使用完成之后将其赋值为null，以减少对应用内存的占用。

Stage模型上同名对象覆盖导致问题的场景举例说明。

1. 在AbilityA文件中使用globalThis存放了[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)。
```
import UIAbility from '@ohos.app.ability.UIAbility'

export default class AbilityA extends UIAbility {
    onCreate(want, launch) {
        globalThis.context = this.context; // AbilityA存放context到globalThis
        // ...
    }
}
```
2. 在AbilityA的页面中获取该[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)并进行使用。使用完成后将AbilityA实例切换至后台。
```
@Entry
@Component
struct Index {
  onPageShow() {
    let ctx = globalThis.context; // 页面中从globalThis中取出context并使用
    let permissions = ['com.example.permission']
    ctx.requestPermissionsFromUser(permissions,(result) => {
       // ...
    });
  }
  // 页面展示
  build() {
    // ...
  }
}
```
3. 在AbilityB文件中使用globalThis存放了[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)，并且命名为相同的名称。
```
import UIAbility from '@ohos.app.ability.UIAbility'

export default class AbilityB extends UIAbility {
    onCreate(want, launch) {
        // AbilityB覆盖了AbilityA在globalThis中存放的context
        globalThis.context = this.context;
        // ...
    }
}
```
4. 在AbilityB的页面中获取该[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)并进行使用。此时获取到的globalThis.context已经表示为AbilityB中赋值的[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)内容。
```
@Entry
@Component
struct Index {
  onPageShow() {
    let ctx = globalThis.context; // Page中从globalThis中取出context并使用
    let permissions = ['com.example.permission']
    ctx.requestPermissionsFromUser(permissions,(result) => {
      console.info('requestPermissionsFromUser result:' + JSON.stringify(result));
    });
  }
  // 页面展示
  build() {
    // ...
  }
}
```
5. 在AbilityB实例切换至后台，将AbilityA实例从后台切换回到前台。此时AbilityA的onCreate生命周期不会再次进入。
```
import UIAbility from '@ohos.app.ability.UIAbility'

export default class AbilityA extends UIAbility {
    onCreate(want, launch) { // AbilityA从后台进入前台，不会再走这个生命周期
        globalThis.context = this.context;
        // ...
    }
}
```
6. 在AbilityA的页面再次回到前台时，其获取到的globalThis.context表示的为AbilityB的[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)，而不是AbilityA的[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)，在AbilityA的页面中使用则会出错。
```
@Entry
@Component
struct Index {
  onPageShow() {
    let ctx = globalThis.context; // 这时候globalThis中的context是AbilityB的context
    let permissions=['com.example.permission'];
    ctx.requestPermissionsFromUser(permissions,(result) => { // 使用这个对象就会导致进程崩溃
       console.info('requestPermissionsFromUser result:' + JSON.stringify(result));
    });
  }
  // 页面展示
  build() {
    // ...
  }
}
```

## 使用AppStorage/LocalStorage进行数据同步

ArkUI提供了AppStorage和LocalStorage两种应用级别的状态管理方案，可用于实现应用级别和UIAbility级别的数据同步。使用这些方案可以方便地管理应用状态，提高应用性能和用户体验。其中，AppStorage是一个全局的状态管理器，适用于多个UIAbility共享同一状态数据的情况；而LocalStorage则是一个局部的状态管理器，适用于单个UIAbility内部使用的状态数据。通过这两种方案，开发者可以更加灵活地控制应用状态，提高应用的可维护性和可扩展性。详细请参见[应用级变量的状态管理](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-application-state-management-overview-0000001529381989-V3)。



# UIAbility组件间交互（设备内）

更新时间: 2024-01-15 12:19

UIAbility是系统调度的最小单元。在设备内的功能模块之间跳转时，会涉及到启动特定的UIAbility，该UIAbility可以是应用内的其他UIAbility，也可以是其他应用的UIAbility（例如启动三方支付UIAbility）。

本章节将从如下场景分别介绍设备内UIAbility间的交互方式。

* [启动应用内的UIAbility](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-intra-device-interaction-0000001478181149-V3#ZH-CN_TOPIC_0000001574248797__%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E5%86%85%E7%9A%84uiability)
* [启动应用内的UIAbility并获取返回结果](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-intra-device-interaction-0000001478181149-V3#ZH-CN_TOPIC_0000001574248797__%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E5%86%85%E7%9A%84uiability%E5%B9%B6%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C)
* [启动其他应用的UIAbility](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-intra-device-interaction-0000001478181149-V3#ZH-CN_TOPIC_0000001574248797__%E5%90%AF%E5%8A%A8%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E7%9A%84uiability)
* [启动其他应用的UIAbility并获取返回结果](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-intra-device-interaction-0000001478181149-V3#ZH-CN_TOPIC_0000001574248797__%E5%90%AF%E5%8A%A8%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E7%9A%84uiability%E5%B9%B6%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C)
* [启动UIAbility的指定页面](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-intra-device-interaction-0000001478181149-V3#ZH-CN_TOPIC_0000001574248797__%E5%90%AF%E5%8A%A8uiability%E7%9A%84%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2)
* [通过Call调用实现UIAbility交互（仅对系统应用开放）](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-intra-device-interaction-0000001478181149-V3#ZH-CN_TOPIC_0000001574248797__%E9%80%9A%E8%BF%87call%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0uiability%E4%BA%A4%E4%BA%92%E4%BB%85%E5%AF%B9%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%BC%80%E6%94%BE)

## 启动应用内的UIAbility

当一个应用内包含多个UIAbility时，存在应用内启动UIAbility的场景。例如在支付应用中从入口UIAbility启动收付款UIAbility。

假设应用中有两个UIAbility：EntryAbility和FuncAbility（可以在同一个Module中，也可以在不同的Module中），需要从EntryAbility的页面中启动FuncAbility。

1. 在EntryAbility中，通过调用startAbility()方法启动UIAbility，[want](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-want-0000001493584192-V3)为UIAbility实例启动的入口参数，其中bundleName为待启动应用的Bundle名称，abilityName为待启动的UIAbility名称，moduleName在待启动的UIAbility属于不同的Module时添加，parameters为自定义信息参数。示例中的context的获取方式参见[获取UIAbility的Context属性](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-usage-0000001427584600-V3#ZH-CN_TOPIC_0000001574088337__%E8%8E%B7%E5%8F%96uiability%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF)。
```
let wantInfo = {
    deviceId: '', // deviceId为空表示本设备
    bundleName: 'com.example.myapplication',
    abilityName: 'FuncAbility',
    moduleName: 'module1', // moduleName非必选
    parameters: { // 自定义信息
        info: '来自EntryAbility Index页面',
    },
}
// context为调用方UIAbility的AbilityContext
this.context.startAbility(wantInfo).then(() => {
    // ...
}).catch((err) => {
    // ...
})
```
2. 在FuncAbility的生命周期回调文件中接收EntryAbility传递过来的参数。
```
import UIAbility from '@ohos.app.ability.UIAbility';
import Window from '@ohos.window';

export default class FuncAbility extends UIAbility {
    onCreate(want, launchParam) {
    // 接收调用方UIAbility传过来的参数
        let funcAbilityWant = want;
        let info = funcAbilityWant?.parameters?.info;
        // ...
    }
}
```
3. 在FuncAbility业务完成之后，如需要停止当前UIAbility实例，在FuncAbility中通过调用terminateSelf()方法实现。
```
// context为需要停止的UIAbility实例的AbilityContext
this.context.terminateSelf((err) => {
    // ...
});
```

## 启动应用内的UIAbility并获取返回结果

在一个EntryAbility启动另外一个FuncAbility时，希望在被启动的FuncAbility完成相关业务后，能将结果返回给调用方。例如在应用中将入口功能和帐号登录功能分别设计为两个独立的UIAbility，在帐号登录UIAbility中完成登录操作后，需要将登录的结果返回给入口UIAbility。

1. 在EntryAbility中，调用startAbilityForResult()接口启动FuncAbility，异步回调中的data用于接收FuncAbility停止自身后返回给EntryAbility的信息。示例中的context的获取方式参见[获取UIAbility的Context属性](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-usage-0000001427584600-V3#ZH-CN_TOPIC_0000001574088337__%E8%8E%B7%E5%8F%96uiability%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF)。
```
let wantInfo = {
    deviceId: '', // deviceId为空表示本设备
    bundleName: 'com.example.myapplication',
    abilityName: 'FuncAbility',
    moduleName: 'module1', // moduleName非必选
    parameters: { // 自定义信息
        info: '来自EntryAbility Index页面',
    },
}
// context为调用方UIAbility的AbilityContext
this.context.startAbilityForResult(wantInfo).then((data) => {
    // ...
}).catch((err) => {
    // ...
})
```
2. 在FuncAbility停止自身时，需要调用terminateSelfWithResult()方法，入参abilityResult为FuncAbility需要返回给EntryAbility的信息。
```
const RESULT_CODE: number = 1001;
let abilityResult = {
    resultCode: RESULT_CODE,
    want: {
        bundleName: 'com.example.myapplication',
        abilityName: 'FuncAbility',
        moduleName: 'module1',
        parameters: {
            info: '来自FuncAbility Index页面',
        },
    },
}
// context为被调用方UIAbility的AbilityContext
this.context.terminateSelfWithResult(abilityResult, (err) => {
    // ...
});
```
3. FuncAbility停止自身后，EntryAbility通过startAbilityForResult()方法回调接收被FuncAbility返回的信息，RESULT_CODE需要与前面的数值保持一致。
```
const RESULT_CODE: number = 1001;

// ...

// context为调用方UIAbility的AbilityContext
this.context.startAbilityForResult(want).then((data) => {
    if (data?.resultCode === RESULT_CODE) {
        // 解析被调用方UIAbility返回的信息
        let info = data.want?.parameters?.info;
        // ...
    }
}).catch((err) => {
    // ...
})
```

## 启动其他应用的UIAbility

启动其他应用的UIAbility，通常用户只需要完成一个通用的操作（例如需要选择一个文档应用来查看某个文档的内容信息），推荐使用[隐式Want启动](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/want-overview-0000001478340877-V3#ZH-CN_TOPIC_0000001574088785__want%E7%9A%84%E7%B1%BB%E5%9E%8B)。系统会根据调用方的want参数来识别和启动匹配到的应用UIAbility。

启动UIAbility有[显式Want启动和隐式Want启动](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/want-overview-0000001478340877-V3)两种方式。

* 显式Want启动：启动一个确定应用的UIAbility，在want参数中需要设置该应用bundleName和abilityName，当需要拉起某个明确的UIAbility时，通常使用显式Want启动方式。
* 隐式Want启动：根据匹配条件由用户选择启动哪一个UIAbility，即不明确指出要启动哪一个UIAbility（abilityName参数未设置），在调用startAbility()方法时，其入参want中指定了一系列的[entities](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3#ZH-CN_TOPIC_0000001574088649__wantconstantentity)字段（表示目标UIAbility额外的类别信息，如浏览器、视频播放器）和[actions](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3#ZH-CN_TOPIC_0000001574088649__wantconstantaction)字段（表示要执行的通用操作，如查看、分享、应用详情等）等参数信息，然后由系统去分析want，并帮助找到合适的UIAbility来启动。当需要拉起其他应用的UIAbility时，开发者通常不知道用户设备中应用的安装情况，也无法确定目标应用的bundleName和abilityName，通常使用隐式Want启动方式。

本章节主要讲解如何通过隐式Want启动其他应用的UIAbility。

1. 将多个待匹配的文档应用安装到设备，在其对应UIAbility的module.json5配置文件中，配置skills的[entities](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3#ZH-CN_TOPIC_0000001574088649__wantconstantentity)字段和[actions](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3#ZH-CN_TOPIC_0000001574088649__wantconstantaction)字段。

```
{
  "module": {
    "abilities": [
      {
        // ...
        "skills": [
          {
            "entities": [
              // ...
              "entity.system.default"
            ],
            "actions": [
              // ...
              "ohos.want.action.viewData"
            ]
          }
        ]
      }
    ]
  }
}
```
2. 在调用方want参数中的entities和action需要被包含在待匹配UIAbility的skills配置的entities和actions中。系统匹配到符合entities和actions参数条件的UIAbility后，会弹出选择框展示匹配到的UIAbility实例列表供用户选择使用。示例中的context的获取方式参见[获取UIAbility的Context属性](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-usage-0000001427584600-V3#ZH-CN_TOPIC_0000001574088337__%E8%8E%B7%E5%8F%96uiability%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF)。

```
let wantInfo = {
    deviceId: '', // deviceId为空表示本设备
    // 如果希望隐式仅在特定的捆绑包中进行查询，请取消下面的注释。
    // bundleName: 'com.example.myapplication',
    action: 'ohos.want.action.viewData',
    // entities可以被省略。
    entities: ['entity.system.default'],
}

// context为调用方UIAbility的AbilityContext
this.context.startAbility(wantInfo).then(() => {
    // ...
}).catch((err) => {
    // ...
})
```

   效果示意如下图所示，点击“打开PDF文档”时，会弹出选择框供用户选择。

   ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231214113213.82728149112755932678666489387332:50001231000000:2800:23F0C45DE48B37E9D09894F75B1CB5A557A83912AF90C102F92FA21140A44C04.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)
3. 在文档应用使用完成之后，如需要停止当前UIAbility实例，通过调用terminateSelf()方法实现。

```
// context为需要停止的UIAbility实例的AbilityContext
this.context.terminateSelf((err) => {
    // ...
});
```

## 启动其他应用的UIAbility并获取返回结果

当使用隐式Want启动其他应用的UIAbility并希望获取返回结果时，调用方需要使用startAbilityForResult()方法启动目标UIAbility。例如主应用中需要启动三方支付并获取支付结果。

1. 在支付应用对应UIAbility的module.json5配置文件中，配置skills的[entities](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3#ZH-CN_TOPIC_0000001574088649__wantconstantentity)字段和[actions](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3#ZH-CN_TOPIC_0000001574088649__wantconstantaction)字段。
```
{
  "module": {
    "abilities": [
      {
        // ...
        "skills": [
          {
            "entities": [
              // ...
              "entity.system.default"
            ],
            "actions": [
              // ...
              "ohos.want.action.editData"
            ]
          }
        ]
      }
    ]
  }
}
```
2. 调用方使用startAbilityForResult()方法启动支付应用的UIAbility，在调用方want参数中的entities和action需要被包含在待匹配UIAbility的skills配置的entities和actions中。异步回调中的data用于后续接收支付UIAbility停止自身后返回给调用方的信息。系统匹配到符合entities和actions参数条件的UIAbility后，会弹出选择框展示匹配到的UIAbility实例列表供用户选择使用。
```
let wantInfo = {
    deviceId: '', // deviceId为空表示本设备
    // uncomment line below if wish to implicitly query only in the specific bundle.
    // bundleName: 'com.example.myapplication',
    action: 'ohos.want.action.editData',
    // entities can be omitted.
    entities: ['entity.system.default'],
}

// context为调用方UIAbility的AbilityContext
this.context.startAbilityForResult(wantInfo).then((data) => {
    // ...
}).catch((err) => {
    // ...
})
```
3. 在支付UIAbility完成支付之后，需要调用terminateSelfWithResult()方法实现停止自身，并将abilityResult参数信息返回给调用方。
```
const RESULT_CODE: number = 1001;
let abilityResult = {
    resultCode: RESULT_CODE,
    want: {
        bundleName: 'com.example.myapplication',
        abilityName: 'EntryAbility',
        moduleName: 'entry',
        parameters: {
            payResult: 'OKay',
        },
    },
}
// context为被调用方UIAbility的AbilityContext
this.context.terminateSelfWithResult(abilityResult, (err) => {
    // ...
});
```
4. 在调用方startAbilityForResult()方法回调中接收支付应用返回的信息，RESULT_CODE需要与前面terminateSelfWithResult()返回的数值保持一致。
```
const RESULT_CODE: number = 1001;

let want = {
  // Want参数信息
};

// context为调用方UIAbility的AbilityContext
this.context.startAbilityForResult(want).then((data) => {
    if (data?.resultCode === RESULT_CODE) {
        // 解析被调用方UIAbility返回的信息
        let payResult = data.want?.parameters?.payResult;
        // ...
    }
}).catch((err) => {
    // ...
})
```

## 启动UIAbility的指定页面

一个UIAbility可以对应多个页面，在不同的场景下启动该UIAbility时需要展示不同的页面，例如从一个UIAbility的页面中跳转到另外一个UIAbility时，希望启动目标UIAbility的指定页面。本文主要讲解目标UIAbility首次启动和目标UIAbility非首次启动两种启动指定页面的场景，以及在讲解启动指定页面之前会讲解到在调用方如何指定启动页面。

### 调用方UIAbility指定启动页面

调用方UIAbility启动另外一个UIAbility时，通常需要跳转到指定的页面。例如FuncAbility包含两个页面（Index对应首页，Second对应功能A页面），此时需要在传入的want参数中配置指定的页面路径信息，可以通过want中的parameters参数增加一个自定义参数传递页面跳转信息。示例中的context的获取方式参见[获取UIAbility的Context属性](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-usage-0000001427584600-V3#ZH-CN_TOPIC_0000001574088337__%E8%8E%B7%E5%8F%96uiability%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF)。

```
let wantInfo = {
    deviceId: '', // deviceId为空表示本设备
    bundleName: 'com.example.myapplication',
    abilityName: 'FuncAbility',
    moduleName: 'module1', // moduleName非必选
    parameters: { // 自定义参数传递页面信息
        router: 'funcA',
    },
}
// context为调用方UIAbility的AbilityContext
this.context.startAbility(wantInfo).then(() => {
    // ...
}).catch((err) => {
    // ...
})
```

### 目标UIAbility首次启动

目标UIAbility首次启动时，在目标UIAbility的onWindowStageCreate()生命周期回调中，解析EntryAbility传递过来的want参数，获取到需要加载的页面信息url，传入windowStage.loadContent()方法。

```
import UIAbility from '@ohos.app.ability.UIAbility'
import Window from '@ohos.window'

export default class FuncAbility extends UIAbility {
    funcAbilityWant;

    onCreate(want, launchParam) {
        // 接收调用方UIAbility传过来的参数
        this.funcAbilityWant = want;
    }

    onWindowStageCreate(windowStage: Window.WindowStage) {
        // Main window is created, set main page for this ability
        let url = 'pages/Index';
        if (this.funcAbilityWant?.parameters?.router) {
            if (this.funcAbilityWant.parameters.router === 'funA') {
                url = 'pages/Second';
            }
        }
        windowStage.loadContent(url, (err, data) => {
            // ...
        });
    }
}
```

### 目标UIAbility非首次启动

经常还会遇到一类场景，当应用A已经启动且处于主页面时，回到桌面，打开应用B，并从应用B再次启动应用A，且需要跳转到应用A的指定页面。例如联系人应用和短信应用配合使用的场景。打开短信应用主页，回到桌面，此时短信应用处于已打开状态且当前处于短信应用的主页。再打开联系人应用主页，进入联系人用户A查看详情，点击短信图标，准备给用户A发送短信，此时会再次拉起短信应用且当前处于短信应用的发送页面。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231214113213.01540436541801536334137907607472:50001231000000:2800:3B1C53467E64E11ABD48469806A08FB90BB717FE7787D02BFBBEC15A35A67D7B.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

针对以上场景，即当应用A的UIAbility实例已创建，并且处于该UIAbility实例对应的主页面中，此时，从应用B中需要再次启动应用A的该UIAbility，并且需要跳转到不同的页面，这种情况下要如何实现呢？

1. 在目标UIAbility中，默认加载的是Index页面。由于当前UIAbility实例之前已经创建完成，此时会进入UIAbility的onNewWant()回调中且不会进入onCreate()和onWindowStageCreate()生命周期回调，在onNewWant()回调中解析调用方传递过来的want参数，并挂在到全局变量globalThis中，以便于后续在页面中获取。
```
import UIAbility from '@ohos.app.ability.UIAbility'

export default class FuncAbility extends UIAbility {
    onNewWant(want, launchParam) {
        // 接收调用方UIAbility传过来的参数
        globalThis.funcAbilityWant = want;
        // ...
    }
}
```
2. 在FuncAbility中，此时需要在Index页面中通过页面路由Router模块实现指定页面的跳转，由于此时FuncAbility对应的Index页面是处于激活状态，不会重新变量声明以及进入aboutToAppear()生命周期回调中。因此可以在Index页面的onPageShow()生命周期回调中实现页面路由跳转的功能。
```
import router from '@ohos.router';

@Entry
@Component
struct Index {
  onPageShow() {
    let funcAbilityWant = globalThis.funcAbilityWant;
    let url2 = funcAbilityWant?.parameters?.router;
    if (url2 && url2 === 'funcA') {
      router.replaceUrl({
        url: 'pages/Second',
      })
    }
  }

  // 页面展示
  build() {
    // ...
  }
}
```

说明

当被调用方[Ability的启动模式](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-launch-type-0000001428061476-V3)设置为multiton启动模式时，每次启动都会创建一个新的实例，那么[onNewWant()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-uiability-0000001493584184-V3#ZH-CN_TOPIC_0000001523808838__abilityonnewwant)回调就不会被用到。

## 通过Call调用实现UIAbility交互（仅对系统应用开放）

Call调用是UIAbility能力的扩展，它为UIAbility提供一种能够被外部调用并与外部进行通信的能力。Call调用支持前台与后台两种启动方式，使UIAbility既能被拉起到前台展示UI，也可以在后台被创建并运行。Call调用在调用方与被调用方间建立了IPC通信，因此应用开发者可通过Call调用实现不同UIAbility之间的数据共享。

Call调用的核心接口是startAbilityByCall方法，与startAbility接口的不同之处在于：

* startAbilityByCall支持前台与后台两种启动方式，而startAbility仅支持前台启动。
* 调用方可使用startAbilityByCall所返回的Caller对象与被调用方进行通信，而startAbility不具备通信能力。

Call调用的使用场景主要包括：

* 需要与被启动的UIAbility进行通信。
* 希望被启动的UIAbility在后台运行。
  表1 Call调用相关名词解释

| 名词          | 描述                                                                                       |
| :------------ | :----------------------------------------------------------------------------------------- |
| CallerAbility | 进行Call调用的UIAbility（调用方）。                                                        |
| CalleeAbility | 被Call调用的UIAbility（被调用方）。                                                        |
| Caller        | 实际对象，由startAbilityByCall接口返回，CallerAbility可使用Caller与CalleeAbility进行通信。 |
| Callee        | 实际对象，被CalleeAbility持有，可与Caller进行通信。                                        |

Call调用示意图如下所示。

图1 Call调用示意图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231214113213.19909720506112455623022369162681:50001231000000:2800:D99E97AFA4A7044E5DF77084C472822BDF282EEC44B2D438E9AD60FC452CA498.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

* CallerAbility调用startAbilityByCall接口获取Caller，并使用Caller对象的call方法向CalleeAbility发送数据。
* CalleeAbility持有一个Callee对象，通过Callee的on方法注册回调函数，当接收到Caller发送的数据时将会调用对应的回调函数。

说明

1. 当前仅支持系统应用使用Call调用。
2. CalleeAbility的启动模式需要为单实例。
3. Call调用既支持本地（设备内）Call调用，也支持跨设备Call调用，下面介绍设备内Call调用方法。

### 接口说明

Call功能主要接口如下表所示。具体的API详见[接口文档](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-uiability-0000001493584184-V3#ZH-CN_TOPIC_0000001523808838__caller)。

表2 Call功能主要接口

| 接口名                                                                             | 描述                                                                                                                                                                                                                                                                                                                                                           |
| :--------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| startAbilityByCall(want: Want): Promise`<Caller>`                                | 启动指定UIAbility并获取其Caller通信接口，默认为后台启动，通过配置want可实现前台启动，详见[接口文档](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3#ZH-CN_TOPIC_0000001523648914__abilitycontextstartabilitybycall)。AbilityContext与ServiceExtensionContext均支持该接口。 |
| on(method: string, callback: CalleeCallBack): void                                 | 通用组件Callee注册method对应的callback方法。                                                                                                                                                                                                                                                                                                                   |
| off(method: string): void                                                          | 通用组件Callee解注册method的callback方法。                                                                                                                                                                                                                                                                                                                     |
| call(method: string, data: rpc.Parcelable): Promise`<void>`                      | 向通用组件Callee发送约定序列化数据。                                                                                                                                                                                                                                                                                                                           |
| callWithResult(method: string, data: rpc.Parcelable): Promise<rpc.MessageSequence> | 向通用组件Callee发送约定序列化数据, 并将Callee返回的约定序列化数据带回。                                                                                                                                                                                                                                                                                       |
| release(): void                                                                    | 释放通用组件的Caller通信接口。                                                                                                                                                                                                                                                                                                                                 |
| on(type: "release", callback: OnReleaseCallback): void                             | 注册通用组件通信断开监听通知。                                                                                                                                                                                                                                                                                                                                 |

设备内通过Call调用实现UIAbility交互，涉及如下两部分开发：

* [创建Callee被调用端](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-intra-device-interaction-0000001478181149-V3#ZH-CN_TOPIC_0000001574248797__%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E5%88%9B%E5%BB%BAcallee%E8%A2%AB%E8%B0%83%E7%94%A8%E7%AB%AF)
* [访问Callee被调用端](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-intra-device-interaction-0000001478181149-V3#ZH-CN_TOPIC_0000001574248797__%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E8%AE%BF%E9%97%AEcallee%E8%A2%AB%E8%B0%83%E7%94%A8%E7%AB%AF)

### 开发步骤（创建Callee被调用端）

在Callee被调用端，需要实现指定方法的数据接收回调函数、数据的序列化及反序列化方法。在需要接收数据期间，通过on接口注册监听，无需接收数据时通过off接口解除监听。

1. 配置Ability的启动模式。
   配置module.json5，将CalleeAbility配置为单实例"singleton"。

   | Json字段     | 字段说明                                   |
   | :----------- | :----------------------------------------- |
   | "launchType" | Ability的启动模式，设置为"singleton"类型。 |

   Ability配置标签示例如下：


```
"abilities":[{
  "name": ".CalleeAbility",
  "srcEntrance": "./ets/CalleeAbility/CalleeAbility.ts",
  "launchType": "singleton",
  "description": "$string:CalleeAbility_desc",
  "icon": "$media:icon",
  "label": "$string:CalleeAbility_label",
  "visible": true
}]
```
2. 导入UIAbility模块。

```
import Ability from '@ohos.app.ability.UIAbility';
```
3. 定义约定的序列化数据。
   调用端及被调用端发送接收的数据格式需协商一致，如下示例约定数据由number和string组成。

```
export default class MyParcelable {
    num: number = 0
    str: string = ""

    constructor(num, string) {
        this.num = num
        this.str = string
    }

    marshalling(messageSequence) {
        messageSequence.writeInt(this.num)
        messageSequence.writeString(this.str)
        return true
    }

    unmarshalling(messageSequence) {
        this.num = messageSequence.readInt()
        this.str = messageSequence.readString()
        return true
    }
}
```
4. 实现Callee.on监听及Callee.off解除监听。
   被调用端Callee的监听函数注册时机，取决于应用开发者。注册监听之前的数据不会被处理，取消监听之后的数据不会被处理。如下示例在Ability的onCreate注册'MSG_SEND_METHOD'监听，在onDestroy取消监听，收到序列化数据后作相应处理并返回，应用开发者根据实际需要做相应处理。具体示例代码如下：

```
const TAG: string = '[CalleeAbility]';
const MSG_SEND_METHOD: string = 'CallSendMsg';

function sendMsgCallback(data) {
    console.info('CalleeSortFunc called');

    // 获取Caller发送的序列化数据
    let receivedData = new MyParcelable(0, '');
    data.readParcelable(receivedData);
    console.info(`receiveData[${receivedData.num}, ${receivedData.str}]`);

    // 作相应处理
    // 返回序列化数据result给Caller
    return new MyParcelable(receivedData.num + 1, `send ${receivedData.str} succeed`);
}

export default class CalleeAbility extends Ability {
    onCreate(want, launchParam) {
        try {
            this.callee.on(MSG_SEND_METHOD, sendMsgCallback);
        } catch (error) {
            console.info(`${MSG_SEND_METHOD} register failed with error ${JSON.stringify(error)}`);
        }
    }

    onDestroy() {
        try {
            this.callee.off(MSG_SEND_METHOD);
        } catch (error) {
            console.error(TAG, `${MSG_SEND_METHOD} unregister failed with error ${JSON.stringify(error)}`);
        }
    }
}
```

### 开发步骤（访问Callee被调用端）

1. 导入UIAbility模块。

```
import Ability from '@ohos.app.ability.UIAbility';
```

1. 获取Caller通信接口。
   Ability的context属性实现了startAbilityByCall方法，用于获取指定通用组件的Caller通信接口。如下示例通过this.context获取Ability实例的context属性，使用startAbilityByCall拉起Callee被调用端并获取Caller通信接口，注册Caller的onRelease监听。应用开发者根据实际需要做相应处理。
```
// 注册caller的release监听
private regOnRelease(caller) {
    try {
        caller.on("release", (msg) => {
            console.info(`caller onRelease is called ${msg}`);
        })
        console.info('caller register OnRelease succeed');
    } catch (error) {
        console.info(`caller register OnRelease failed with ${error}`);
    }
}

async onButtonGetCaller() {
    try {
        this.caller = await context.startAbilityByCall({
            bundleName: 'com.samples.CallApplication',
            abilityName: 'CalleeAbility'
        })
        if (this.caller === undefined) {
            console.info('get caller failed')
            return
        }
        console.info('get caller success')
        this.regOnRelease(this.caller)
    } catch (error) {
        console.info(`get caller failed with ${error}`)
    }
}
```



# ExtensionAbility组件

更新时间: 2024-01-15 11:54

ExtensionAbility组件是基于特定场景提供的应用组件，以便满足更多的使用场景。

每一个具体场景对应一个[ExtensionAbilityType](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-bundlemanager-0000001427585060-V3#ZH-CN_TOPIC_0000001573928977__extensionabilitytype)，各类型的ExtensionAbility组件均由相应的系统服务统一管理，例如InputMethodExtensionAbility组件由输入法管理服务统一管理。当前支持的ExtensionAbility类型有：

* [FormExtensionAbility](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formextensionability-0000001493424316-V3)：FORM类型的ExtensionAbility组件，用于提供服务卡片场景相关能力。
* [WorkSchedulerExtensionAbility](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-workschedulerextensionability-0000001493904024-V3)：WORK_SCHEDULER类型的ExtensionAbility组件，用于提供延迟任务注册、取消、查询的能力。



# 服务卡片概述

更新时间: 2024-01-15 12:18

服务卡片（以下简称“卡片”）是一种界面展示形式，可以将应用的重要信息或操作前置到卡片，以达到服务直达、减少体验层级的目的。卡片常用于嵌入到其他应用（当前卡片使用方只支持系统应用，如桌面）中作为其界面显示的一部分，并支持拉起页面、发送消息等基础的交互功能。

## 服务卡片架构

图1 服务卡片架构
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183814.74418918220942473260145035291638:50001231000000:2800:1BD7D15EDA828031E9F488ED2B9A2B0E0CFD1D1818671193260C63E765D80D4F.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

卡片的基本概念：

* 卡片使用方：如上图中的桌面，显示卡片内容的宿主应用，控制卡片在宿主中展示的位置。
  * 应用图标：应用入口图标，点击后可拉起应用进程，图标内容不支持交互。
  * 卡片：具备不同规格大小的界面展示，卡片的内容可以进行交互，如实现按钮进行[界面的刷新](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-event-formextensionability-0000001502350018-V3)、[应用的跳转](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-event-router-0000001502352142-V3)等。
* 卡片提供方：包含卡片的应用，提供卡片的显示内容、控件布局以及控件点击处理逻辑。
  * FormExtensionAbility：卡片业务逻辑模块，提供卡片创建、销毁、刷新等生命周期回调。
  * 卡片页面：卡片UI模块，包含页面控件、布局、事件等显示和交互信息。

卡片的常见使用步骤如下。

图2 卡片常见使用步骤
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183815.23783470585251911305223424038868:50001231000000:2800:346425871F81DA48E170C8077D585E7F94433E5F57FBF0761E36FBDDD937D9CC.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

1. 长按“桌面图标”，弹出操作菜单。
2. 点击“服务卡片”选项，进入卡片预览界面。
3. 点击“添加到桌面”按钮，即可在桌面上看到新添加的卡片。

## 服务卡片UI页面开发方式

在Stage模型下，服务卡片的UI页面支持通过[ArkTS](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-working-principles-0000001485485850-V3)和[JS](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/js-ui-widget-development-0000001535946225-V3)两种语言进行开发：

* 基于声明式范式ArkTS UI开发的卡片，简称ArkTS卡片。
* 基于类Web范式JS UI开发的卡片，简称JS卡片。

ArkTS卡片与JS卡片具备不同的实现原理及特征，在场景能力上的差异如下表所示。

| 类别                             | JS卡片    | ArkTS卡片  |
| :------------------------------- | :-------- | :--------- |
| 开发范式                         | 类Web范式 | 声明式范式 |
| 组件能力                         | 支持      | 支持       |
| 布局能力                         | 支持      | 支持       |
| 事件能力                         | 支持      | 支持       |
| 自定义动效                       | 不支持    | 支持       |
| 自定义绘制                       | 不支持    | 支持       |
| 逻辑代码执行（不包含import能力） | 不支持    | 支持       |

相比于JS卡片，ArkTS卡片在能力和场景方面更加丰富，因此无论开发何种用途的卡片，都推荐使用ArkTS卡片，因为它可以提高开发效率并实现动态化。但如果只需要做静态页面展示的卡片，可以考虑使用JS卡片。



# ArkTS卡片运行机制

更新时间: 2024-01-15 12:19

## 实现原理

图1 ArkTS卡片实现原理
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183815.84950479601709236953856307066692:50001231000000:2800:24CE798F44299BD4053A0967CBAD12932312EA9CA22571F526C914EC9FDDAFE9.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

* 卡片使用方：显示卡片内容的宿主应用，控制卡片在宿主中展示的位置，当前仅系统应用可以作为卡片使用方。
* 卡片提供方：提供卡片显示内容的应用，控制卡片的显示内容、控件布局以及控件点击事件。
* 卡片管理服务：用于管理系统中所添加卡片的常驻代理服务，提供[formProvider](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formprovider-0000001544464081-V3)接口能力，同时提供卡片对象的管理与使用以及卡片周期性刷新等能力。
* 卡片渲染服务：用于管理卡片渲染实例，渲染实例与卡片使用方上的卡片组件一一绑定。卡片渲染服务运行卡片页面代码widgets.abc进行渲染，并将渲染后的数据发送至卡片使用方对应的卡片组件。

图2 ArkTS卡片渲染服务运行原理
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183815.70324623892566542504943558891522:50001231000000:2800:D0976010FBE176746DD88FF624885BD25BAAF25B71B956FF9BCB81F13528EBFA.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

与JS卡片相比，ArkTS卡片支持在卡片中运行逻辑代码，为确保ArkTS卡片发生问题后不影响卡片使用方应用的使用，ArkTS卡片新增了卡片渲染服务用于运行卡片页面代码widgets.abc，卡片渲染服务由卡片管理服务管理。卡片使用方的每个卡片组件都对应了卡片渲染服务里的一个渲染实例，同一应用提供方的渲染实例运行在同一个虚拟机运行环境中，不同应用提供方的渲染实例运行在不同的虚拟机运行环境中，通过虚拟机运行环境隔离不同应用提供方卡片之间的资源与状态。开发过程中需要注意的是globalThis对象的使用，相同应用提供方的卡片globalThis对象是同一个，不同应用提供方的卡片globalThis对象是不同的。

## ArkTS卡片的优势

卡片作为应用的一个快捷入口，ArkTS卡片相较于JS卡片具备如下几点优势：

* 统一开发范式，提升开发体验和开发效率。OpenHarmony在2022年发布了声明式范式的UI开发框架，而卡片还延续了css/hml/json三段式类Web范式的开发方式，提高了开发者的学习成本，提供ArkTS卡片能力后，统一了卡片和页面的开发范式，页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。

  图3 卡片工程结构对比
  ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183815.31341413307437818634965999621111:50001231000000:2800:A0700F36404CC8476BFB529FC8474D1AE441340772C11E186493AF60E4199792.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")
* 增强了卡片的能力，使卡片更加万能。

  * 新增了动效的能力：ArkTS卡片开放了[属性动画](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-animatorproperty-0000001478181445-V3)和[显式动画](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-explicit-animation-0000001478341181-V3)的能力，使卡片的交互更加友好。
  * 新增了自定义绘制的能力：ArkTS卡片开放了Canvas画布组件，卡片可以使用自定义绘制的能力构建更多样的显示和交互效果。
  * 允许卡片中运行逻辑代码：开放逻辑代码运行后很多业务逻辑可以在卡片内部自闭环，拓宽了卡片的业务适用场景。

## ArkTS卡片的约束

ArkTS卡片相较于JS卡片具备了更加丰富的能力，但也增加了使用卡片进行恶意行为的风险。由于ArkTS卡片显示在使用方应用中，使用方应用一般为桌面应用，为确保桌面的使用体验以及功耗相关考虑，对ArkTS卡片的能力做了以下约束：

* 不支持加载so。
* 不支持使用native语言开发。
* 仅支持声明式范式的[部分](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-page-overview-0000001553173049-V3)组件、事件、动效、数据管理、状态管理和API能力。
* 卡片的事件处理和使用方的事件处理是独立的，建议在使用方支持左右滑动的场景下卡片内容不要使用左右滑动功能的组件，以防手势冲突影响交互体验。

除此之外，当前ArkTS卡片还存在如下约束：

* 暂不支持导入模块。
* 暂不支持极速预览。
* 暂不支持断点调试能力。
* 暂不支持Hot Reload热重载。



# ArkTS卡片相关模块

更新时间: 2024-01-15 12:20

图1 ArkTS卡片相关模块
![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183816.58959716451617224104657554983988:50001231000000:2800:66F5D0DCFE26D6E5FA8C71D3F18AF038D10CE3C9B80652B6956E45906CB91634.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

* [FormExtensionAbility](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formextensionability-0000001493424316-V3)：卡片扩展模块，提供卡片创建、销毁、刷新等生命周期回调。
* FormExtensionContext：FormExtensionAbility的上下文环境，提供FormExtensionAbility具有的接口和能力。
* [formProvider](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formprovider-0000001544464081-V3)：提供卡片提供方相关的接口能力，可通过该模块提供接口实现更新卡片、设置卡片更新时间、获取卡片信息、请求发布卡片等。
* [formInfo](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-forminfo-0000001493903980-V3)：提供了卡片信息和状态等相关类型和枚举。
* [formBindingData](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formbindingdata-0000001544703921-V3)：提供卡片数据绑定的能力，包括FormBindingData对象的创建、相关信息的描述。
* [页面布局（Card.ets）](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-page-overview-0000001553173049-V3)：提供声明式范式的UI接口能力。
  * [ArkTS卡片特有能力](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-event-overview-0000001553069581-V3)：postCardAction用于卡片内部和提供方应用间的交互，仅在卡片中可以调用。
  * [ArkTS卡片能力列表](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-page-overview-0000001553173049-V3#section17744162145013)：列举了能在ArkTS卡片中使用的API、组件、事件、属性和生命周期调度。
* [卡片配置](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-configuration-0000001502333060-V3)：包含FormExtensionAbility的配置和卡片的配置
  * 在[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)中的extensionAbilities标签下，配置FormExtensionAbility相关信息。
  * 在resources/base/profile/目录下的[form_config.json配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-configuration-0000001502333060-V3#ZH-CN_TOPIC_0000001523808634__table959386016151722)中，配置卡片（WidgetCard.ets）相关信息。



# 创建一个ArkTS卡片

更新时间: 2024-01-15 12:21

在已有的应用工程中，创建ArkTS卡片，具体操作方式如下。

1. 创建卡片。![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183817.81291228310849866946600703717633:50001231000000:2800:3A6E498B8F1A94217EA4D297AC8F15A61F88250BA42F62BB9627F3A8971814A8.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)
2. 根据实际业务场景，选择一个卡片模板。![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183817.46672294524475328680770744347800:50001231000000:2800:7380C58BEC31854226E1ED6022FD9221F9E1AA447798F6B048970B7B28D94E89.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)
3. 在选择卡片的开发语言类型（Language）时，选择ArkTS选项，然后单击“Finish”，即可完成ArkTS卡片创建。![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183817.95023210862394647888612560833566:50001231000000:2800:9F6080F352504E63A27A7896A9C36D10D5DA753378B950738135271532932D8C.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

ArkTS卡片创建完成后，工程中会新增如下卡片相关文件：卡片生命周期管理文件（EntryFormAbility.ts）、卡片页面文件（WidgetCard.ets）和卡片配置文件（form_config.json）。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183817.61904831379757444774168874514389:50001231000000:2800:34D5A8661908768849C1FE20027FB9FEFB6AF863A76A6686EC04C8E2172864E3.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)



# 配置卡片的配置文件

更新时间: 2024-01-15 11:54

卡片相关的配置文件主要包含FormExtensionAbility的配置和卡片的配置两部分：

1. 卡片需要在module.json5配置文件中的extensionAbilities标签下，配置FormExtensionAbility相关信息。FormExtensionAbility需要填写metadata元信息标签，其中键名称为固定字符串“ohos.extension.form”，资源为卡片的具体配置信息的索引。
   配置示例如下：

```
{
  "module": {
    ...
    "extensionAbilities": [
      {
        "name": "EntryFormAbility",
        "srcEntrance": "./ets/entryformability/EntryFormAbility.ts",
        "label": "$string:EntryFormAbility_label",
        "description": "$string:EntryFormAbility_desc",
        "type": "form",
        "metadata": [
          {
            "name": "ohos.extension.form",
            "resource": "$profile:form_config"
          }
        ]
      }
    ]
  }
}
```
2. 卡片的具体配置信息。在上述FormExtensionAbility的元信息（“metadata”配置项）中，可以指定卡片具体配置信息的资源索引。例如当resource指定为$profile:form_config时，会使用开发视图的resources/base/profile/目录下的form_config.json作为卡片profile配置文件。内部字段结构说明如下表所示。
  表1 卡片form_config.json配置文件
  | 属性名称            | 含义                                                                                                                                                                                                                                                                                                                            | 数据类型   | 是否可缺省                     |
  | :-------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- | :------------------------------- |
  | name                | 表示卡片的类名，字符串最大长度为127字节。                                                                                                                                                                                                                                                                                       | 字符串     | 否                             |
  | description         | 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。该属性将显示在[卡片预览](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/service-widget-overview-0000001536226057-V3#ZH-CN_TOPIC_0000001523648622__fig149024251313)界面上，以便用户识别不同卡片。 | 字符串     | 可缺省，缺省为空。             |
  | src                 | 表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如："./ets/widget/pages/WidgetCard.ets"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如："./js/widget/pages/WidgetCard"                                                                                                                      | 字符串     | 否                             |
  | uiSyntax            | 表示该卡片的类型，当前支持如下两种类型：- arkts：当前卡片为ArkTS卡片。- hml：当前卡片为JS卡片。                                                                                                                                                                                                                                 | 字符串     | 可缺省，缺省值为hml            |
  | window              | 用于定义与显示窗口相关的配置。                                                                                                                                                                                                                                                                                                  | 对象       | 可缺省                         |
  | isDefault           | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。- true：默认卡片。- false：非默认卡片。                                                                                                                                                                                                                            | 布尔值     | 否                             |
  | colorMode           | 表示卡片的主题样式，取值范围如下：- auto：自适应。- dark：深色主题。- light：浅色主题。                                                                                                                                                                                                                                         | 字符串     | 可缺省，缺省值为“auto”。     |
  | supportDimensions   | 表示卡片支持的外观规格，取值范围：- 1 * 2：表示1行2列的二宫格。- 2 * 2：表示2行2列的四宫格。- 2 * 4：表示2行4列的八宫格。- 4 * 4：表示4行4列的十六宫格。                                                                                                                                                                        | 字符串数组 | 否                             |
  | defaultDimension    | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。                                                                                                                                                                                                                                                         | 字符串     | 否                             |
  | updateEnabled       | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：- true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。- false：表示不支持周期性刷新。                                                                              | 布尔类型   | 否                             |
  | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。> 说明：> updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。                                                                                                                                                   | 字符串     | 可缺省，缺省时不进行定点刷新。 |
  | updateDuration      | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。> 说明：> updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。                                                                     | 数值       | 可缺省，缺省值为“0”。        |
  | formConfigAbility   | 表示卡片的配置跳转链接，采用URI格式。                                                                                                                                                                                                                                                                                           | 字符串     | 可缺省，缺省值为空。           |
  | formVisibleNotify   | 标识是否允许卡片使用卡片可见性通知。                                                                                                                                                                                                                                                                                            | 字符串     | 可缺省，缺省值为空。           |
  | metadata            | 表示卡片的自定义信息，包含customizeData数组标签。                                                                                                                                                                                                                                                                               | 对象       | 可缺省，缺省值为空。           |

  配置示例如下：

```
{
  "forms": [
    {
      "name": "widget",
      "description": "This is a service widget.",
      "src": "./ets/widget/pages/WidgetCard.ets",
      "uiSyntax": "arkts",
      "window": {
        "designWidth": 720,
        "autoDesignWidth": true
      },
      "colorMode": "auto",
      "isDefault": true,
      "updateEnabled": true,
      "scheduledUpdateTime": "10:30",
      "updateDuration": 1,
      "defaultDimension": "2*2",
      "supportDimensions": [
        "2*2"
      ]
    }
  ]
}
```



# 卡片生命周期管理

更新时间: 2024-01-15 12:22

创建ArkTS卡片，需实现[FormExtensionAbility](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formextensionability-0000001493424316-V3)生命周期接口。

1. 在EntryFormAbility.ts中，导入相关模块。
```
import formInfo from '@ohos.app.form.formInfo';
import formBindingData from '@ohos.app.form.formBindingData';
import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';
import formProvider from '@ohos.app.form.formProvider';
```
2. 在EntryFormAbility.ts中，实现FormExtensionAbility生命周期接口，其中在onAddForm的入参want中可以通过FormParam取出卡片的相关信息。
```
import formInfo from '@ohos.app.form.formInfo';
import formBindingData from '@ohos.app.form.formBindingData';
import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';
import formProvider from '@ohos.app.form.formProvider';

export default class EntryFormAbility extends FormExtensionAbility {
  onAddForm(want) {
    console.info('[EntryFormAbility] onAddForm');
    // 在入参want中可以取出卡片的唯一标识：formId
    let formId: string = want.parameters[formInfo.FormParam.IDENTITY_KEY];
    // 使用方创建卡片时触发，提供方需要返回卡片数据绑定类
    let obj = {
      'title': 'titleOnAddForm',
      'detail': 'detailOnAddForm'
    };
    let formData = formBindingData.createFormBindingData(obj);
    return formData;
  }

  onCastToNormalForm(formId) {
    // Called when the form provider is notified that a temporary form is successfully
    // converted to a normal form.
    // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理
    console.info(`[EntryFormAbility] onCastToNormalForm, formId: ${formId}`);
  }

  onUpdateForm(formId) {
    // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新
    console.info('[EntryFormAbility] onUpdateForm');
    let obj = {
      'title': 'titleOnUpdateForm',
      'detail': 'detailOnUpdateForm'
    };
    let formData = formBindingData.createFormBindingData(obj);
    formProvider.updateForm(formId, formData).catch((err) => {
      if (err) {
        // 异常分支打印
        console.error(`[EntryFormAbility] Failed to updateForm. Code: ${err.code}, message: ${err.message}`);
        return;
      }
    });
  }

  onChangeFormVisibility(newStatus) {
    // Called when the form provider receives form events from the system.
    // 需要配置formVisibleNotify为true，且为系统应用才会回调
    console.info('[EntryFormAbility] onChangeFormVisibility');
  }

  onFormEvent(formId, message) {
    // Called when a specified message event defined by the form provider is triggered.
    // 若卡片支持触发事件，则需要重写该方法并实现对事件的触发
    console.info('[EntryFormAbility] onFormEvent');
  }

  onRemoveForm(formId) {
    // Called to notify the form provider that a specified form has been destroyed.
    // 当对应的卡片删除时触发的回调，入参是被删除的卡片ID
    console.info('[EntryFormAbility] onRemoveForm');
  }

  onConfigurationUpdate(config) {
    // 当系统配置信息置更新时触发的回调
    console.info('[EntryFormAbility] configurationUpdate:' + JSON.stringify(config));
  }

  onAcquireFormState(want) {
    // Called to return a {@link FormState} object.
    // 卡片提供方接收查询卡片状态通知接口，默认返回卡片初始状态。
    return formInfo.FormState.READY;
  }
}
```

说明

FormExtensionAbility进程不能常驻后台，即在卡片生命周期回调函数中无法处理长时间的任务，在生命周期调度完成后会继续存在5秒，如5秒内没有新的生命周期回调触发则进程自动退出。针对可能需要5秒以上才能完成的业务逻辑，建议[拉起主应用](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-event-uiability-0000001553309573-V3)进行处理，处理完成后使用updateForm通知卡片进行刷新。



# 卡片页面能力说明

更新时间: 2024-01-15 12:23

开发者可以使用声明式范式开发ArkTS卡片页面。如下卡片页面由DevEco Studio模板自动生成，开发者可以根据自身的业务场景进行调整。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183818.30381953403938475821459542469921:50001231000000:2800:E82D08DDAEDEDFD7F926089A8D2C3BB47450C63E09A876C97D1F1B6D73477436.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

ArkTS卡片具备JS卡片的全量能力，并且新增了动效能力和自定义绘制的能力，支持[声明式范式](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-components-summary-0000001478181369-V3)的部分组件、事件、动效、数据管理、状态管理能力，详见“[ArkTS卡片支持的页面能力](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-page-overview-0000001553173049-V3#section17744162145013)”。

## ArkTS卡片支持的页面能力

ArkTS卡片支持的页面能力如下，详细介绍请参见[ArkTS声明式开发范式API参考](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-components-summary-0000001478181369-V3)。

在这些能力中，只有标识“支持在ArkTS卡片中使用”的具体能力可用于ArkTS卡片，同时请留意卡片场景下的能力差异说明。

* 属性动画
* 显式动画
* 组件内转场
* 像素单位
* Blank组件
* Button组件
* Checkbox组件
* CheckboxGroup组件
* DataPanel组件
* Divider组件
* Gauge组件
* Image组件
* LoadingProgress组件
* Marquee组件
* Progress组件
* Qrcode组件
* Radio组件
* Rating组件
* Slider组件
* Span组件
* Text组件
* Toggle组件
* Canvas绘制上下文对象
* Canvas组件
* 渐变对象
* ImageBitmap对象
* ImageData对象
* Path2D对象
* ForEach组件
* Badge容器组件
* Column容器组件
* Counter容器组件
* Flex容器组件
* GridCol容器组件
* GridRow容器组件
* List容器组件
* ListItem容器组件
* RelativeContainer容器组件
* Row容器组件
* Stack容器组件
* Circle绘制组件
* Ellipse绘制组件
* Line绘制组件
* Path绘制组件
* Polygon绘制组件
* Polyline绘制组件
* Rect绘制组件
* Shape绘制组件
* Background通用属性
* BackgroundBlurStyle通用属性
* BorderImage通用属性
* Border通用属性
* ComponentId通用属性
* Enable通用属性
* FlexLayout通用属性
* GradientColor通用属性
* ImageEffect通用属性
* LayoutConstraints通用属性
* Location通用属性
* Opacity通用属性
* Overlay通用属性
* PolymorphicStyle通用属性
* SharpClipping通用属性
* Size通用属性
* Touch-target通用属性
* Transformation通用属性
* Visibility通用属性
* ZOrder通用属性
* 点击事件
* 挂载卸载事件
* 组件生命周期
* 状态管理



# 卡片使用动效能力

更新时间: 2024-01-15 12:23

ArkTS卡片开放了使用动画效果的能力，支持显式动画、属性动画、组件内转场能力。需要注意的是，ArkTS卡片使用动画效果时具有以下限制：

表1 动效参数限制
| 名称 | 参数说明 | 限制描述 |
| :- | :- | :- |
| ---------------------------- |

| duration   | 动画播放时长       | 限制最长的动效播放时长为1秒，当设置大于1秒的时间时，动效时长仍为1秒。 |
| ---------- | ------------------ | --------------------------------------------------------------------- |
| tempo      | 动画播放速度       | 卡片中禁止设置此参数，使用默认值1。                                   |
| delay      | 动画延迟执行的时长 | 卡片中禁止设置此参数，使用默认值0。                                   |
| iterations | 动画播放次数       | 卡片中禁止设置此参数，使用默认值1。                                   |

以下示例代码实现了按钮旋转的动画效果：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183818.18389183536541864636311638623803:50001231000000:2800:F30D25E4A0734B7452590F95C7824A1198137A382FEC8239D39C08BE509C0518.gif?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

```
@Entry
@Component
struct AttrAnimationExample {
  @State rotateAngle: number = 0;

  build() {
    Column() {
      Button('change rotate angle')
        .onClick(() => {
          this.rotateAngle = 90;
        })
        .margin(50)
        .rotate({ angle: this.rotateAngle })
        .animation({
          curve: Curve.EaseOut,
          playMode: PlayMode.AlternateReverse
        })
    }.width('100%').margin({ top: 20 })
  }
}
```



# 卡片使用自定义绘制能力

更新时间: 2024-01-15 12:24

ArkTS卡片开放了自定义绘制的能力，在卡片上可以通过[Canvas](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-components-canvas-canvas-0000001427744852-V3)组件创建一块画布，然后通过[CanvasRenderingContext2D](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-canvasrenderingcontext2d-0000001478181441-V3)对象在画布上进行自定义图形的绘制，如下示例代码实现了在画布的中心绘制了一个笑脸。

```
@Entry
@Component
struct Card {
  private canvasWidth: number = 0;
  private canvasHeight: number = 0;
  // 初始化CanvasRenderingContext2D和RenderingContextSettings
  private settings: RenderingContextSettings = new RenderingContextSettings(true);
  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);

  build() {
    Column() {
      Row() {
        Canvas(this.context)
          .margin('5%')
          .width('90%')
          .height('90%')
          .onReady(() => {
            console.info('[ArkTSCard] onReady for canvas draw content');
            // 在onReady回调中获取画布的实际宽和高
            this.canvasWidth = this.context.width;
            this.canvasHeight = this.context.height;
            // 绘制画布的背景
            this.context.fillStyle = 'rgba(203, 154, 126, 1.00)';
            this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            // 在画布的中心绘制一个红色的圆
            this.context.beginPath();
            let radius = this.context.width / 3
            let circleX = this.context.width / 2
            let circleY = this.context.height / 2
            this.context.moveTo(circleX - radius, circleY);
            this.context.arc(circleX, circleY, radius, 2 * Math.PI, 0, true);
            this.context.closePath();
            this.context.fillStyle = 'red';
            this.context.fill();
            // 绘制笑脸的左眼
            let leftR = radius / 4
            let leftX = circleX - (radius / 2)
            let leftY = circleY - (radius / 3.5)
            this.context.beginPath();
            this.context.arc(leftX, leftY, leftR, 0, Math.PI, true);
            this.context.strokeStyle = '#ffff00'
            this.context.lineWidth = 10
            this.context.stroke()
            // 绘制笑脸的右眼
            let rightR = radius / 4
            let rightX = circleX + (radius / 2)
            let rightY = circleY - (radius / 3.5)
            this.context.beginPath();
            this.context.arc(rightX, rightY, rightR, 0, Math.PI, true);
            this.context.strokeStyle = '#ffff00'
            this.context.lineWidth = 10
            this.context.stroke()
            // 绘制笑脸的嘴巴
            let mouthR = radius / 2.5
            let mouthX = circleX
            let mouthY = circleY + (radius / 3)
            this.context.beginPath();
            this.context.arc(mouthX, mouthY, mouthR, Math.PI, 0, true);
            this.context.strokeStyle = '#ffff00'
            this.context.lineWidth = 10
            this.context.stroke()
          })
      }
    }.height('100%').width('100%')
  }
}
```

运行效果如下图所示。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183818.58694057328028931819074222153116:50001231000000:2800:D0C9D6067BBC4274904A3414E4F718E02E087BC2E0A782817CC78965E3D5A73B.jpeg?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")



# 卡片事件能力说明

更新时间: 2024-01-15 12:23

ArkTS卡片中提供了postCardAction()接口用于卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件，仅在卡片中可以调用。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183819.64313290145113371011422165128259:50001231000000:2800:F14A06471AA2A01BA4A6C5E5DA8DAC7EE7A75244BF8FAC7956BF7374CA70C2D5.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

接口定义：postCardAction(component: Object, action: Object): void

接口参数说明：

| 参数名 | 参数类型 | 必填 | 参数描述                   |
| :--------------- | :----------------- | :------------- | :----------------------------------- |
| component        | Object             | 是             | 当前自定义组件的实例，通常传入this。 |
| action           | Object             | 是             | action的具体描述，详情见下表。       |

action参数说明：

| Key | Value | 样例描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| :------------ | :-------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| "action"      | string          | action的类型，支持三种预定义的类型：* "router"：跳转到提供方应用的指定UIAbility。* "message"：自定义消息。触发后会调用提供方FormExtensionAbility的onFormEvent()生命周期回调。* "call"：后台启动提供方应用。触发后会拉起提供方应用的指定UIAbility（仅支持[launchType](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-launch-type-0000001428061476-V3)为singleton的UIAbility，即启动模式为单实例的UIAbility），但不会调度到前台。提供方应用需要具备后台运行权限（ohos.permission.KEEP_BACKGROUND_RUNNING）。 |
| "bundleName"  | string          | "router" / "call" 类型时跳转的包名，可选。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| "moduleName"  | string          | "router" / "call" 类型时跳转的模块名，可选。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| "abilityName" | string          | "router" / "call" 类型时跳转的UIAbility名，必填。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| "params"      | Object          | 当前action携带的额外参数，内容使用JSON格式的键值对形式。"call"类型时需填入参数'method'，且类型需要为string类型，用于触发UIAbility中对应的方法，必填。                                                                                                                                                                                                                                                                                                                                                                                  |

postCardAction()接口示例代码：

```
Button('跳转')
  .width('40%')
  .height('20%')
  .onClick(() => {
    postCardAction(this, {
      'action': 'router',
      'bundleName': 'com.example.myapplication',
      'abilityName': 'EntryAbility',
      'params': {
        'message': 'testForRouter' // 自定义要发送的message
      }
    });
  })
```

```
Button('拉至后台')
  .width('40%')
  .height('20%')
  .onClick(() => {
    postCardAction(this, {
      'action': 'call',
      'bundleName': 'com.example.myapplication',
      'abilityName': 'EntryAbility',
      'params': {
        'method': 'fun', // 自定义调用的方法名，必填
        'message': 'testForCall' // 自定义要发送的message
      }
    });
  })
```

以下介绍通过卡片事件实现的典型开发场景。



# 使用router事件跳转到指定UIAbility

更新时间: 2024-01-15 12:23

在卡片中使用postCardAction接口的router能力，能够快速拉起卡片提供方应用的指定UIAbility，因此UIAbility较多的应用往往会通过卡片提供不同的跳转按钮，实现一键直达的效果。例如相机卡片，卡片上提供拍照、录像等按钮，点击不同按钮将拉起相机应用的不同UIAbility，从而提升用户的体验。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183819.03602813329588850411386644697169:50001231000000:2800:7E22361997E98ECA714C32DDE78D54756A5EB4B351225F398F48C3A276F003CC.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

通常使用按钮控件来实现页面拉起，示例代码如下：

* 在卡片页面中布局两个按钮，点击其中一个按钮时调用postCardAction向指定UIAbility发送router事件，并在事件内定义需要传递的内容。
```
@Entry
@Component
struct WidgetCard {
  build() {
    Column() {
      Button('功能A')
        .margin('20%')
        .onClick(() => {
          console.info('Jump to EntryAbility funA');
          postCardAction(this, {
            'action': 'router',
            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility
            'params': {
              'targetPage': 'funA' // 在EntryAbility中处理这个信息
            }
          });
        })

      Button('功能B')
        .margin('20%')
        .onClick(() => {
          console.info('Jump to EntryAbility funB');
          postCardAction(this, {
            'action': 'router',
            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility
            'params': {
              'targetPage': 'funB' // 在EntryAbility中处理这个信息
            }
          });
        })
    }
    .width('100%')
    .height('100%')
  }
}
```
* 在UIAbility中接收router事件并获取参数，根据传递的params不同，选择拉起不同的页面。
```
import UIAbility from '@ohos.app.ability.UIAbility';
import window from '@ohos.window';

let selectPage = "";
let currentWindowStage = null;

export default class CameraAbility extends UIAbility {
  // 如果UIAbility第一次启动，在收到Router事件后会触发onCreate生命周期回调
  onCreate(want, launchParam) {
    // 获取router事件中传递的targetPage参数
    console.info("onCreate want:" + JSON.stringify(want));
    if (want.parameters.params !== undefined) {
      let params = JSON.parse(want.parameters.params);
      console.info("onCreate router targetPage:" + params.targetPage);
      selectPage = params.targetPage;
    }
  }
  // 如果UIAbility已在后台运行，在收到Router事件后会触发onNewWant生命周期回调
  onNewWant(want, launchParam) {
    console.info("onNewWant want:" + JSON.stringify(want));
    if (want.parameters.params !== undefined) {
      let params = JSON.parse(want.parameters.params);
      console.info("onNewWant router targetPage:" + params.targetPage);
      selectPage = params.targetPage;
    }
    if (currentWindowStage != null) {
      this.onWindowStageCreate(currentWindowStage);
    }
  }

  onWindowStageCreate(windowStage: window.WindowStage) {
    let targetPage;
    // 根据传递的targetPage不同，选择拉起不同的页面
    switch (selectPage) {
      case 'funA':
        targetPage = 'pages/FunA';
        break;
      case 'funB':
        targetPage = 'pages/FunB';
        break;
      default:
        targetPage = 'pages/Index';
    }
    if (currentWindowStage === null) {
      currentWindowStage = windowStage;
    }
    windowStage.loadContent(targetPage, (err, data) => {
      if (err && err.code) {
        console.info('Failed to load the content. Cause: %{public}s', JSON.stringify(err));
        return;
      }
    });
  }
};
```



# 使用call事件拉起指定UIAbility到后台

更新时间: 2024-01-15 11:54

许多应用希望借助卡片的能力，实现和应用在前台时相同的功能。例如音乐卡片，卡片上提供播放、暂停等按钮，点击不同按钮将触发音乐应用的不同功能，进而提高用户的体验。在卡片中使用postCardAction接口的call能力，能够将卡片提供方应用的指定UIAbility拉到后台。同时，call能力提供了调用应用指定方法、传递数据的功能，使应用在后台运行时可以通过卡片上的按钮执行不同的功能。

通常使用按钮控件来触发call事件，示例代码如下：

* 在卡片页面中布局两个按钮，点击其中一个按钮时调用postCardAction向指定UIAbility发送call事件，并在事件内定义需要调用的方法和传递的数据。需要注意的是，method参数为必选参数，且类型需要为string类型，用于触发UIAbility中对应的方法。
```
@Entry
@Component
struct WidgetCard {
  build() {
    Column() {
      Button('功能A')
        .margin('20%')
        .onClick(() => {
          console.info('call EntryAbility funA');
          postCardAction(this, {
            'action': 'call',
            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility
            'params': {
              'method': 'funA' // 在EntryAbility中调用的方法名
            }
          });
        })
       Button('功能B')
        .margin('20%')
        .onClick(() => {
          console.info('call EntryAbility funB');
          postCardAction(this, {
            'action': 'call',
            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility
            'params': {
              'method': 'funB', // 在EntryAbility中调用的方法名
              'num': 1 // 需要传递的其他参数
            }
          });
        })
    }
    .width('100%')
    .height('100%')
  }
}
```
* 在UIAbility中接收call事件并获取参数，根据传递的method不同，执行不同的方法。其余数据可以通过readString的方式获取。需要注意的是，UIAbility需要onCreate生命周期中监听所需的方法。
```
import UIAbility from '@ohos.app.ability.UIAbility';
 
function FunACall(data) {
  // 获取call事件中传递的所有参数
  console.log('FunACall param:' + JSON.stringify(data.readString()));
  return null;
}
 function FunBCall(data) {
  console.log('FunACall param:' + JSON.stringify(data.readString()));
  return null;
}
 
export default class CameraAbility extends UIAbility {
  // 如果UIAbility第一次启动，在收到call事件后会触发onCreate生命周期回调
  onCreate(want, launchParam) {
      try {
          // 监听call事件所需的方法
          this.callee.on('funA', FunACall);
          this.callee.on('funB', FunBCall);
      } catch (error) {
          console.log('register failed with error. Cause: ' + JSON.stringify(error));
      }
  }
   
  // 进程退出时，解除监听
  onDestroy() {
      try {
          this.callee.off('funA');
          this.callee.off('funB');
      } catch (error) {
          console.log('register failed with error. Cause: ' + JSON.stringify(error));
      }
  }
};
```



# 通过message事件刷新卡片内容

更新时间: 2024-01-15 12:25

在卡片页面中可以通过postCardAction接口触发message事件拉起FormExtensionAbility，然后由FormExtensionAbility刷新卡片内容，下面是这种刷新方式的简单示例。

* 在卡片页面通过注册Button的onClick点击事件回调，并在回调中调用postCardAction接口触发message事件拉起FormExtensionAbility。

```
let storage = new LocalStorage();

@Entry(storage)
@Component
struct WidgetCard {
  @LocalStorageProp('title') title: string = 'init';
  @LocalStorageProp('detail') detail: string = 'init';

  build() {
    Column() {
      Button('刷新')
        .onClick(() => {
          postCardAction(this, {
            'action': 'message',
            'params': {
              'msgTest': 'messageEvent'
            }
          });
        })
      Text(`${this.title}`)
      Text(`${this.detail}`)
    }
    .width('100%')
    .height('100%')
  }
}
```
* 在FormExtensionAbility的onFormEvent生命周期中调用updateForm接口刷新卡片。

```
import formBindingData from '@ohos.app.form.formBindingData';
import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';
import formProvider from '@ohos.app.form.formProvider';

export default class EntryFormAbility extends FormExtensionAbility {
  onFormEvent(formId, message) {
    // Called when a specified message event defined by the form provider is triggered.
    console.info(`FormAbility onEvent, formId = ${formId}, message: ${JSON.stringify(message)}`);
    let formData = {
      'title': 'Title Update Success.', // 和卡片布局中对应
      'detail': 'Detail Update Success.', // 和卡片布局中对应
    };
    let formInfo = formBindingData.createFormBindingData(formData)
    formProvider.updateForm(formId, formInfo).then((data) => {
      console.info('FormAbility updateForm success.' + JSON.stringify(data));
    }).catch((error) => {
      console.error('FormAbility updateForm failed: ' + JSON.stringify(error));
    })
  }

  ...
}
```

  运行效果如下图所示。

  ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183819.67493386673415860980849818971052:50001231000000:2800:5596EADBA3EEA07F179E38C4B057DE0D76C4BAF6ACD367AAED2DBF6FE5EC21D8.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")



# 通过router或call事件刷新卡片内容

更新时间: 2024-01-15 11:54

在卡片页面中可以通过postCardAction接口触发router或call事件拉起UIAbility，然后由UIAbility刷新卡片内容，下面是这种刷新方式的简单示例。

## 通过router事件刷新卡片内容

* 在卡片页面通过注册Button的onClick点击事件回调，并在回调中调用postCardAction接口触发router事件拉起UIAbility。

```
let storage = new LocalStorage();

@Entry(storage)
@Component
struct WidgetCard {
  @LocalStorageProp('detail') detail: string = 'init';

  build() {
    Column() {
      Button('跳转')
        .margin('20%')
        .onClick(() => {
          console.info('postCardAction to EntryAbility');
          postCardAction(this, {
            'action': 'router',
            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility
            'params': {
              'detail': 'RouterFromCard'
            }
          });
        })
      Text(`${this.detail}`).margin('20%')
    }
    .width('100%')
    .height('100%')
  }
}
```

* 在UIAbility的onCreate()或者onNewWant()生命周期中可以通过入参want获取卡片的formID和传递过来的参数信息，然后调用updateForm接口刷新卡片。
```
import UIAbility from '@ohos.app.ability.UIAbility';
import formBindingData from '@ohos.app.form.formBindingData';
import formProvider from '@ohos.app.form.formProvider';
import formInfo from '@ohos.app.form.formInfo';

export default class EntryAbility extends UIAbility {
  // 如果UIAbility第一次启动，在收到Router事件后会触发onCreate生命周期回调
  onCreate(want, launchParam) {
    console.info('Want:' + JSON.stringify(want));
    if (want.parameters[formInfo.FormParam.IDENTITY_KEY] !== undefined) {
      let curFormId = want.parameters[formInfo.FormParam.IDENTITY_KEY];
      let message = JSON.parse(want.parameters.params).detail;
      console.info(`UpdateForm formId: ${curFormId}, message: ${message}`);
      let formData = {
        "detail": message + ': onCreate UIAbility.', // 和卡片布局中对应
      };
      let formMsg = formBindingData.createFormBindingData(formData)
      formProvider.updateForm(curFormId, formMsg).then((data) => {
        console.info('updateForm success.' + JSON.stringify(data));
      }).catch((error) => {
        console.error('updateForm failed:' + JSON.stringify(error));
      })
    }
  }
  // 如果UIAbility已在后台运行，在收到Router事件后会触发onNewWant生命周期回调
  onNewWant(want, launchParam) {
    console.info('onNewWant Want:' + JSON.stringify(want));
    if (want.parameters[formInfo.FormParam.IDENTITY_KEY] !== undefined) {
      let curFormId = want.parameters[formInfo.FormParam.IDENTITY_KEY];
      let message = JSON.parse(want.parameters.params).detail;
      console.info(`UpdateForm formId: ${curFormId}, message: ${message}`);
      let formData = {
        "detail": message + ': onNewWant UIAbility.', // 和卡片布局中对应
      };
      let formMsg = formBindingData.createFormBindingData(formData)
      formProvider.updateForm(curFormId, formMsg).then((data) => {
        console.info('updateForm success.' + JSON.stringify(data));
      }).catch((error) => {
        console.error('updateForm failed:' + JSON.stringify(error));
      })
    }
  }

  ...
}
```

## 通过call事件刷新卡片内容

* 在使用postCardAction接口的call事件时，需要在FormExtensionAbility中的onAddForm生命周期回调中更新formId。

```
import formBindingData from '@ohos.app.form.formBindingData'; 
import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';

export default class EntryFormAbility extends FormExtensionAbility {
  onAddForm(want) {
   let formId = want.parameters["ohos.extra.param.key.form_identity"];
   let dataObj1 = {
     "formId": formId
   };
   let obj1 = formBindingData.createFormBindingData(dataObj1);
   return obj1;
 }
    
 ...
};
```

* 在卡片页面通过注册Button的onClick点击事件回调，并在回调中调用postCardAction接口触发call事件拉起UIAbility。
```
let storage = new LocalStorage();

@Entry(storage)
@Component
struct WidgetCard {
  @LocalStorageProp('detail') detail: string = 'init';
  @LocalStorageProp('formId') formId: string = '0';

  build() {
    Column() {
      Button('拉至后台')
        .margin('20%')
        .onClick(() => {
          console.info('postCardAction to EntryAbility');
          postCardAction(this, {
            'action': 'call',
            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility
            'params': {
              'method': 'funA',
              'formId': this.formId,
              'detail': 'CallFromCard'
            }
          });
        })
      Text(`${this.detail}`).margin('20%')
    }
    .width('100%')
    .height('100%')
  }
}
```
* 在UIAbility的onCreate生命周期中监听call事件所需的方法，然后调用updateForm接口刷新卡片。
```
import UIAbility from '@ohos.app.ability.UIAbility';
import formBindingData from '@ohos.app.form.formBindingData';
import formProvider from '@ohos.app.form.formProvider';
import formInfo from '@ohos.app.form.formInfo';
const MSG_SEND_METHOD: string = 'funA'
 
// 在收到call事件后会触发callee监听的方法
function FunACall(data) {
  // 获取call事件中传递的所有参数
  let params = JSON.parse(data.readString())
  if (params.formId !== undefined) {
    let curFormId = params.formId;
    let message = params.detail;
    console.info(`UpdateForm formId: ${curFormId}, message: ${message}`);
    let formData = {
      "detail": message
    };
    let formMsg = formBindingData.createFormBindingData(formData)
    formProvider.updateForm(curFormId, formMsg).then((data) => {
      console.info('updateForm success.' + JSON.stringify(data));
    }).catch((error) => {
      console.error('updateForm failed:' + JSON.stringify(error));
    })
  }
  return null;
}
export default class EntryAbility extends UIAbility {
  // 如果UIAbility第一次启动，call事件后会触发onCreate生命周期回调
  onCreate(want, launchParam) {
    console.info('Want:' + JSON.stringify(want));
    try {
       // 监听call事件所需的方法
      this.callee.on(MSG_SEND_METHOD, FunACall);
    } catch (error) {
      console.log(`${MSG_SEND_METHOD} register failed with error ${JSON.stringify(error)}`)
    }
  }
  ...
}
```



# 卡片数据交互说明

更新时间: 2024-01-15 12:24

ArkTS卡片框架提供了updateForm()接口和requestForm()接口主动触发卡片的页面刷新。

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183819.01402491542662555973018250125079:50001231000000:2800:FF1AC116533BDD04701231F7E91BF4C77DF992B1F3BC7662C0DD0AF302C68690.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

| 接口        | 是否系统能力 | 约束                                                                                 |
| :---------- | :----------- | :----------------------------------------------------------------------------------- |
| updateForm  | 否           | 1. 提供方调用。2. 提供方仅允许刷新自己的卡片，其他提供方的卡片无法刷新。             |
| requestForm | 是           | 1. 使用方调用。2. 仅允许刷新添加到当前使用方的卡片，添加到其他使用方的卡片无法刷新。 |

下面介绍卡片页面刷新的典型场景。



# 定时刷新和定点刷新

更新时间: 2024-01-15 12:24

当前卡片框架提供了如下几种按时间刷新卡片的方式：

* 定时刷新：表示在一定时间间隔内调用[onUpdateForm](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formextensionability-0000001493424316-V3#ZH-CN_TOPIC_0000001573928781__onupdateform)的生命周期回调函数自动刷新卡片内容。可以在form_config.json配置文件的[updateDuration](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-configuration-0000001502333060-V3#ZH-CN_TOPIC_0000001523808634__table959386016151722)字段中进行设置。例如，可以将刷新时间设置为每小时一次。注意：updateDuration（定时刷新）优先级比scheduledUpdateTime（定点刷新）高，配置定时刷新后，定点刷新将失效。

```
{
  "forms": [
    {
      "name": "widget",
      "description": "This is a service widget.",
      "src": "./ets/widget/pages/WidgetCard.ets",
      "uiSyntax": "arkts",
      "window": {
        "designWidth": 720,
        "autoDesignWidth": true
      },
      "colorMode": "auto",
      "isDefault": true,
      "updateEnabled": true, // 使能刷新功能
      "scheduledUpdateTime": "10:30",                               
      "updateDuration": 2, // 设置卡片定时刷新的更新周期（单位为30分钟，取值为自然数）
      "defaultDimension": "2*2",
      "supportDimensions": ["2*2"]
    }
  ]
}
```
* 定点刷新：表示每天在某个时间点刷新，在form_config.json文件中配置，详见[scheduledUpdateTime](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-configuration-0000001502333060-V3#ZH-CN_TOPIC_0000001523808634__table959386016151722)字段。例如，每天在10:30更新卡片内容。

  说明

  当同时配置了定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）时，定时刷新的优先级更高。如果想要配置定点刷新，则需要将updateDuration配置为0。

```
{
  "forms": [
    {
      "name": "widget",
      "description": "This is a service widget.",
      "src": "./ets/widget/pages/WidgetCard.ets",
      "uiSyntax": "arkts",
      "window": {
        "designWidth": 720,
        "autoDesignWidth": true
      },
      "colorMode": "auto",
      "isDefault": true,
      "updateEnabled": true, // 使能刷新功能
      "scheduledUpdateTime": "10:30", // 设置卡片的定点刷新的时刻
      "updateDuration": 0,
      "defaultDimension": "2*2",
      "supportDimensions": ["2*2"]
    }
  ]
}
```
* 下次刷新：通过setFormNextRefreshTime接口指定卡片的下一次刷新时间（最短时间5分钟），例如，在接口调用的5分钟后刷新卡片内容。

```
import formProvider from '@ohos.app.form.formProvider';

let formId = '123456789'; // 实际业务场景需要使用正确的formId
try {
  // 设置过5分钟后更新卡片内容
  formProvider.setFormNextRefreshTime(formId, 5, (err, data) => {
    if (err) {
      console.error(`Failed to setFormNextRefreshTime. Code: ${err.code}, message: ${err.message}`);
      return;
    } else {
      console.info('Succeeded in setFormNextRefreshTimeing.');
    }
  });
} catch (err) {
  console.error(`Failed to setFormNextRefreshTime. Code: ${err.code}, message: ${err.message}`);
}
```

在触发定时、定点或主动刷新后，系统会调用FormExtensionAbility的onUpdateForm生命周期回调，在回调中，可以使用updateForm进行提供方刷新卡片。onUpdateForm生命周期回调参考[通过FormExtensionAbility刷新卡片内容](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-event-formextensionability-0000001502350018-V3)。

说明

1. 定时刷新有配额限制，每张卡片每天最多通过定时方式触发刷新50次，定时刷新包含[卡片配置项updateDuration](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-widget-configuration-0000001502333060-V3#ZH-CN_TOPIC_0000001523808634__table959386016151722)和调用setFormNextRefreshTime两种，当达到50次配额后，无法通过定时方式再次触发刷新，刷新次数会在每天的0点重置。
2. 当前定时刷新使用同一个计时器进行计时，因此卡片定时刷新的第一次刷新会有最多30分钟的偏差。比如第一张卡片A(每隔半小时刷新一次)在3点20分添加成功，定时器启动并每隔半小时触发一次事件，第二张卡片B(每隔半小时刷新一次)在3点40分添加成功，在3点50分定时器事件触发时，卡片A触发定时刷新，卡片B会在下次事件(4点20分)中才会触发。
3. 定时刷新和定点刷新仅在屏幕亮屏情况下才会触发，在灭屏场景下仅会将记录刷新动作，待亮屏时统一进行刷新。



# 刷新本地图片和网络图片

更新时间: 2024-01-15 12:25

在卡片上通常需要展示本地图片或从网络上下载的图片，获取本地图片和网络图片需要通过FormExtensionAbility来实现，如下示例代码介绍了如何在卡片上显示本地图片和网络图片。

1. 下载网络图片需要使用到网络能力，需要申请ohos.permission.INTERNET权限，配置方式请参见[配置文件权限声明](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/accesstoken-guidelines-0000001493744016-V3#ZH-CN_TOPIC_0000001574088333__%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%A3%B0%E6%98%8E)。
2. 在EntryFormAbility中的onAddForm生命周期回调中实现本地文件的刷新。
```
import formBindingData from '@ohos.app.form.formBindingData';
import formProvider from '@ohos.app.form.formProvider';
import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';
import request from '@ohos.request';
import fs from '@ohos.file.fs';

export default class EntryFormAbility extends FormExtensionAbility {
  ...
  // 在添加卡片时，打开一个本地图片并将图片内容传递给卡片页面显示
  onAddForm(want) {
    // 假设在当前卡片应用的tmp目录下有一个本地图片：head.PNG
    let tempDir = this.context.getApplicationContext().tempDir;
    // 打开本地图片并获取其打开后的fd
    let file;
    try {
      file = fs.openSync(tempDir + '/' + 'head.PNG');
    } catch (e) {
      console.error(`openSync failed: ${JSON.stringify(e)}`);
    }
    let formData = {
      'text': 'Image: Bear',
      'imgName': 'imgBear',
      'formImages': {
        'imgBear': file.fd
      },
      'loaded': true
    }
    // 将fd封装在formData中并返回至卡片页面
    return formBindingData.createFormBindingData(formData);
  }

  ...
}
```
3. 在EntryFormAbility中的onFormEvent生命周期回调中实现网络文件的刷新。
```
import formBindingData from '@ohos.app.form.formBindingData';
import formProvider from '@ohos.app.form.formProvider';
import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';
import request from '@ohos.request';
import fs from '@ohos.file.fs';

export default class EntryFormAbility extends FormExtensionAbility {
  // 在卡片页面触发message事件时，下载一个网络图片，并将网络图片内容传递给卡片页面显示
  onFormEvent(formId, message) {
    let formInfo = formBindingData.createFormBindingData({
      'text': '刷新中...'
    })
    formProvider.updateForm(formId, formInfo)
    // 注意：FormExtensionAbility在触发生命周期回调时被拉起，仅能在后台存在5秒
    // 建议下载能快速下载完成的小文件，如在5秒内未下载完成，则此次网络图片无法刷新至卡片页面上
    let netFile = 'https://xxxx/xxxx.png'; // 需要在此处使用真实的网络图片下载链接
    let tempDir = this.context.getApplicationContext().tempDir;
    let tmpFile = tempDir + '/file' + Date.now();
    request.downloadFile(this.context, {
      url: netFile, filePath: tmpFile
    }).then((task) => {
      task.on('complete', function callback() {
        console.info('ArkTSCard download complete:' + tmpFile);
        let file;
        try {
          file = fs.openSync(tmpFile);
        } catch (e) {
          console.error(`openSync failed: ${JSON.stringify(e)}`);
        }
        let formData = {
          'text': 'Image: Https',
          'imgName': 'imgHttps',
          'formImages': {
            'imgHttps': file.fd
          },
          'loaded': true
        }
        let formInfo = formBindingData.createFormBindingData(formData)
        formProvider.updateForm(formId, formInfo).then((data) => {
          console.info('FormAbility updateForm success.' + JSON.stringify(data));
        }).catch((error) => {
          console.error('FormAbility updateForm failed: ' + JSON.stringify(error));
        })
      })
      task.on('fail', function callBack(err) {
        console.info('ArkTSCard download task failed. Cause:' + err);
        let formInfo = formBindingData.createFormBindingData({
          'text': '刷新失败'
        })
        formProvider.updateForm(formId, formInfo)
      });
    }).catch((err) => {
      console.error('Failed to request the download. Cause: ' + JSON.stringify(err));
    });
  }

  ...
};
```
4. 在卡片页面通过Image组件展示EntryFormAbility传递过来的卡片内容。
```
let storage = new LocalStorage();

@Entry(storage)
@Component
struct WidgetCard {
  @LocalStorageProp('text') text: string = '加载中...';
  @LocalStorageProp('loaded') loaded: boolean = false;
  @LocalStorageProp('imgName') imgName: string = 'name';

  build() {
    Column() {
      Text(this.text)
        .fontSize('12vp')
        .textAlign(TextAlign.Center)
        .width('100%')
        .height('15%')

      Row() {
        if (this.loaded) {
          Image('memory://' + this.imgName)
            .width('50%')
            .height('50%')
            .margin('5%')
        } else {
          Image('common/start.PNG')
            .width('50%')
            .height('50%')
            .margin('5%')
        }
      }.alignItems(VerticalAlign.Center)
      .justifyContent(FlexAlign.Center)

      Button('刷新')
        .height('15%')
        .onClick(() => {
          postCardAction(this, {
            'action': 'message',
            'params': {
              'info': 'refreshImage'
            }
          });
        })
    }
    .width('100%').height('100%')
    .alignItems(HorizontalAlign.Center)
    .padding('5%')
  }
}
```

说明

* Image组件通过入参( memory://fileName )中的 memory:// 标识来进行远端内存图片显示，其中fileName需要和EntryFormAbility传递对象( 'formImages  ': {key  : fd}) 中的key相对应。
* Image组件通过传入的参数是否有变化来决定是否刷新图片，因此EntryFormAbility每次传递过来的imgName都需要不同，连续传递两个相同的imgName时，图片不会刷新。



# 根据卡片状态刷新不同内容

更新时间: 2024-01-15 12:25

相同的卡片可以添加到桌面上实现不同的功能，比如添加两张桌面的卡片，一张显示杭州的天气，一张显示北京的天气，设置每天早上7点触发定时刷新，卡片需要感知当前的配置是杭州还是北京，然后将对应城市的天气信息刷新到卡片上，以下示例介绍了如何根据卡片的状态动态选择需要刷新的内容。

* 卡片配置文件：配置每天早上7点触发定时刷新
```
{
  "forms": [
    {
      "name": "widget",
      "description": "This is a service widget.",
      "src": "./ets/widget/pages/WidgetCard.ets",
      "uiSyntax": "arkts",
      "window": {
        "designWidth": 720,
        "autoDesignWidth": true
      },
      "colorMode": "auto",
      "isDefault": true,
      "updateEnabled": true,
      "scheduledUpdateTime": "07:00",
      "updateDuration": 0,
      "defaultDimension": "2*2",
      "supportDimensions": ["2*2"]
    }
  ]
}
```
* 卡片页面：卡片具备不同的状态选择，在不同的状态下需要刷新不同的内容，因此在状态发生变化时通过postCardAction通知EntryFormAbility。
```
let storage = new LocalStorage();
@Entry(storage)
@Component
struct WidgetCard {
  @LocalStorageProp('textA') textA: string = '待刷新...';
  @LocalStorageProp('textB') textB: string = '待刷新...';
  @State selectA: boolean = false;
  @State selectB: boolean = false;

  build() {
    Column() {
      Row() {
        Checkbox({ name: 'checkbox1', group: 'checkboxGroup' })
          .select(false)
          .onChange((value: boolean) => {
            this.selectA = value;
            postCardAction(this, {
              'action': 'message',
              'params': {
                'selectA': JSON.stringify(value)
              }
            });
          })
        Text('状态A')
      }

      Row() {
        Checkbox({ name: 'checkbox2', group: 'checkboxGroup' })
          .select(false)
          .onChange((value: boolean) => {
            this.selectB = value;
            postCardAction(this, {
              'action': 'message',
              'params': {
                'selectB': JSON.stringify(value)
              }
            });
          })
        Text('状态B')
      }

      Row() { // 选中状态A才会进行刷新的内容
        Text('状态A: ')
        Text(this.textA)
      }

      Row() { // 选中状态B才会进行刷新的内容
        Text('状态B: ')
        Text(this.textB)
      }
    }.padding('10%')
  }
}
```
* EntryFormAbility：将卡片的状态存储在本地数据库中，在刷新事件回调触发时，通过formId获取当前卡片的状态，然后根据卡片的状态选择不同的刷新内容。
```
import formInfo from '@ohos.app.form.formInfo'
import formProvider from '@ohos.app.form.formProvider';
import formBindingData from '@ohos.app.form.formBindingData';
import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';
import dataStorage from '@ohos.data.storage'

export default class EntryFormAbility extends FormExtensionAbility {
  onAddForm(want) {
    let formId = want.parameters[formInfo.FormParam.IDENTITY_KEY];
    let isTempCard: boolean = want.parameters[formInfo.FormParam.TEMPORARY_KEY];
    if (isTempCard === false) { // 如果为常态卡片，直接进行信息持久化
      console.info('Not temp card, init db for:' + formId);
      let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')
      storeDB.putSync('A' + formId, 'false');
      storeDB.putSync('B' + formId, 'false');
      storeDB.flushSync();
    }
    let formData = {};
    return formBindingData.createFormBindingData(formData);
  }

  onRemoveForm(formId) {
    console.info('onRemoveForm, formId:' + formId);
    let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')
    storeDB.deleteSync('A' + formId);
    storeDB.deleteSync('B' + formId);
  }

  // 如果在添加时为临时卡片，则建议转为常态卡片时进行信息持久化
  onCastToNormalForm(formId) {
    console.info('onCastToNormalForm, formId:' + formId);
    let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')
    storeDB.putSync('A' + formId, 'false');
    storeDB.putSync('B' + formId, 'false');
    storeDB.flushSync();
  }

  onUpdateForm(formId) {
    let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')
    let stateA = storeDB.getSync('A' + formId, 'false').toString()
    let stateB = storeDB.getSync('B' + formId, 'false').toString()
    // A状态选中则更新textA
    if (stateA === 'true') {
      let formInfo = formBindingData.createFormBindingData({
        'textA': 'AAA'
      })
      formProvider.updateForm(formId, formInfo)
    }
    // B状态选中则更新textB
    if (stateB === 'true') {
      let formInfo = formBindingData.createFormBindingData({
        'textB': 'BBB'
      })
      formProvider.updateForm(formId, formInfo)
    }
  }

  onFormEvent(formId, message) {
    // 存放卡片状态
    console.info('onFormEvent formId:' + formId + 'msg:' + message);
    let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')
    let msg = JSON.parse(message)
    if (msg.selectA != undefined) {
      console.info('onFormEvent selectA info:' + msg.selectA);
      storeDB.putSync('A' + formId, msg.selectA);
    }
    if (msg.selectB != undefined) {
      console.info('onFormEvent selectB info:' + msg.selectB);
      storeDB.putSync('B' + formId, msg.selectB);
    }
    storeDB.flushSync();
  }
};
```

说明

通过本地数据库进行卡片信息的持久化时，建议先在[onAddForm](https://gitee.com/openharmony/docs/blob/078894ac6252e195d0f2fabf98c33a0863497c92/zh-cn/application-dev/reference/apis/js-apis-app-form-formExtensionAbility.md#onaddform)生命周期中通过[TEMPORARY_KEY](https://gitee.com/openharmony/docs/blob/078894ac6252e195d0f2fabf98c33a0863497c92/zh-cn/application-dev/reference/apis/js-apis-app-form-formInfo.md#formparam)判断当前添加的卡片是否为常态卡片：如果是常态卡片，则直接进行卡片信息持久化；如果为临时卡片，则可以在卡片转为常态卡片([onCastToNormalForm](https://gitee.com/openharmony/docs/blob/078894ac6252e195d0f2fabf98c33a0863497c92/zh-cn/application-dev/reference/apis/js-apis-app-form-formExtensionAbility.md#oncasttonormalform))时进行持久化；同时需要在卡片销毁([onRemoveForm](https://gitee.com/openharmony/docs/blob/078894ac6252e195d0f2fabf98c33a0863497c92/zh-cn/application-dev/reference/apis/js-apis-app-form-formExtensionAbility.md#onremoveform))时删除当前卡片存储的持久化信息，避免反复添加删除卡片导致数据库文件持续变大。



# 开发基于JS UI的卡片

更新时间: 2024-01-15 12:19

以下内容介绍基于类Web范式的JS UI卡片开发指南。

## 运作机制

卡片框架的运作机制如图1所示。

图1 卡片框架运作机制（Stage模型）

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183820.81296915290162682082632865826544:50001231000000:2800:F959134287A3E4ABB9B97CD4DC3C8206B41AC96E8BD6FAC3F328BF1CAA5292B0.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

卡片使用方包含以下模块：

* 卡片使用：包含卡片的创建、删除、请求更新等操作。
* 通信适配层：由OpenHarmony SDK提供，负责与卡片管理服务通信，用于将卡片的相关操作到卡片管理服务。

卡片管理服务包含以下模块：

* 周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。
* 卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。
* 卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。
* 卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。
* 通信适配层：负责与卡片使用方和提供方进行RPC通信。

卡片提供方包含以下模块：

* 卡片服务：由卡片提供方开发者实现，开发者实现生命周期处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。
* 卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。
* 通信适配层：由OpenHarmony SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务。

说明

实际开发时只需要作为卡片提供方进行卡片内容的开发，卡片使用方和卡片管理服务由系统自动处理。

## 接口说明

FormExtensionAbility类拥有如下API接口，具体的API介绍详见[接口文档](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formextensionability-0000001493424316-V3)。

| 接口名                                                             | 描述                                         |
| :----------------------------------------------------------------- | :------------------------------------------- |
| onAddForm(want: Want): formBindingData.FormBindingData             | 卡片提供方接收创建卡片的通知接口。           |
| onCastToNormalForm(formId: string): void                           | 卡片提供方接收临时卡片转常态卡片的通知接口。 |
| onUpdateForm(formId: string): void                                 | 卡片提供方接收更新卡片的通知接口。           |
| onChangeFormVisibility(newStatus: { [key: string]: number }): void | 卡片提供方接收修改可见性的通知接口。         |
| onFormEvent(formId: string, message: string): void                 | 卡片提供方接收处理卡片事件的通知接口。       |
| onRemoveForm(formId: string): void                                 | 卡片提供方接收销毁卡片的通知接口。           |
| onConfigurationUpdate(config: Configuration): void                 | 当系统配置更新时调用。                       |
| onShareForm?(formId: string): { [key: string]: any }               | 卡片提供方接收卡片分享的通知接口。           |

formProvider类有如下API接口，具体的API介绍详见[接口文档](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formprovider-0000001544464081-V3)。

| 接口名                                                                                                 | 描述                                              |
| :----------------------------------------------------------------------------------------------------- | :------------------------------------------------ |
| setFormNextRefreshTime(formId: string, minute: number, callback: AsyncCallback`<void>`): void;       | 设置指定卡片的下一次更新时间。                    |
| setFormNextRefreshTime(formId: string, minute: number): Promise`<void>`;                             | 设置指定卡片的下一次更新时间，以promise方式返回。 |
| updateForm(formId: string, formBindingData: FormBindingData, callback: AsyncCallback`<void>`): void; | 更新指定的卡片。                                  |
| updateForm(formId: string, formBindingData: FormBindingData): Promise`<void>`;                       | 更新指定的卡片，以promise方式返回。               |

formBindingData类有如下API接口，具体的API介绍详见[接口文档](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-form-formbindingdata-0000001544703921-V3)。

| 接口名                             | 描述                     |
| :--------------------------------- | :----------------------- |
| createFormBindingData(obj?: Object | string): FormBindingData |

## 开发步骤

Stage卡片开发，即基于Stage模型的卡片提供方开发，主要涉及如下关键步骤：

* [创建卡片FormExtensionAbility](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/js-ui-widget-development-0000001535946225-V3#ZH-CN_TOPIC_0000001523968486__%E5%88%9B%E5%BB%BA%E5%8D%A1%E7%89%87formextensionability)：卡片生命周期回调函数FormExtensionAbility开发。
* [配置卡片配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/js-ui-widget-development-0000001535946225-V3#ZH-CN_TOPIC_0000001523968486__%E9%85%8D%E7%BD%AE%E5%8D%A1%E7%89%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)：配置应用配置文件module.json5和profile配置文件。
* [卡片信息的持久化](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/js-ui-widget-development-0000001535946225-V3#ZH-CN_TOPIC_0000001523968486__%E5%8D%A1%E7%89%87%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96)：对卡片信息进行持久化管理。
* [卡片数据交互](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/js-ui-widget-development-0000001535946225-V3#ZH-CN_TOPIC_0000001523968486__%E5%8D%A1%E7%89%87%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92)：通过updateForm更新卡片显示的信息。
* [开发卡片页面](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/js-ui-widget-development-0000001535946225-V3#ZH-CN_TOPIC_0000001523968486__%E5%BC%80%E5%8F%91%E5%8D%A1%E7%89%87%E9%A1%B5%E9%9D%A2)：使用HML+CSS+JSON开发JS卡片页面。
* [开发卡片事件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/js-ui-widget-development-0000001535946225-V3#ZH-CN_TOPIC_0000001523968486__%E5%BC%80%E5%8F%91%E5%8D%A1%E7%89%87%E4%BA%8B%E4%BB%B6)：为卡片添加router事件和message事件。

### 创建卡片FormExtensionAbility

创建Stage模型的卡片，需实现FormExtensionAbility生命周期接口。先参考[DevEco Studio服务卡片开发指南](https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ide_service_widget-0000001078566997)生成服务卡片模板。

1. 在EntryFormAbility.ts中，导入相关模块。
```
import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';
import formBindingData from '@ohos.app.form.formBindingData';
import formInfo from '@ohos.app.form.formInfo';
import formProvider from '@ohos.app.form.formProvider';
import dataStorage from '@ohos.data.storage';
```
2. 在EntryFormAbility.ts中，实现FormExtension生命周期接口。
```
export default class EntryFormAbility extends FormExtensionAbility {
    onAddForm(want) {
        console.info('[EntryFormAbility] onAddForm');
        // 使用方创建卡片时触发，提供方需要返回卡片数据绑定类
        let obj = {
            "title": "titleOnCreate",
            "detail": "detailOnCreate"
        };
        let formData = formBindingData.createFormBindingData(obj);
        return formData;
    }
    onCastToNormalForm(formId) {
        // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理
        console.info('[EntryFormAbility] onCastToNormalForm');
    }
    onUpdateForm(formId) {
        // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新
        console.info('[EntryFormAbility] onUpdateForm');
        let obj = {
            "title": "titleOnUpdate",
            "detail": "detailOnUpdate"
        };
        let formData = formBindingData.createFormBindingData(obj);
        formProvider.updateForm(formId, formData).catch((error) => {
            console.info('[EntryFormAbility] updateForm, error:' + JSON.stringify(error));
        });
    }
    onChangeFormVisibility(newStatus) {
        // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，仅系统应用生效
        console.info('[EntryFormAbility] onChangeFormVisibility');
    }
    onFormEvent(formId, message) {
        // 若卡片支持触发事件，则需要重写该方法并实现对事件的触发
        console.info('[EntryFormAbility] onFormEvent');
    }
    onRemoveForm(formId) {
        // 删除卡片实例数据
        console.info('[EntryFormAbility] onRemoveForm');
    }
    onConfigurationUpdate(config) {
        console.info('[EntryFormAbility] nConfigurationUpdate, config:' + JSON.stringify(config));
    }
    onAcquireFormState(want) {
        return formInfo.FormState.READY;
    }
}
```

说明

FormExtensionAbility不能常驻后台，即在卡片生命周期回调函数中无法处理长时间的任务。

### 配置卡片配置文件

1. 卡片需要在[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)中的extensionAbilities标签下，配置ExtensionAbility相关信息。FormExtensionAbility需要填写metadata元信息标签，其中键名称为固定字符串"ohos.extension.form"，资源为卡片的具体配置信息的索引。
  配置示例如下：

```
{
  "module": {
    ...
    "extensionAbilities": [
      {
        "name": "EntryFormAbility",
        "srcEntrance": "./ets/entryformability/EntryFormAbility.ts",
        "label": "$string:EntryFormAbility_label",
        "description": "$string:EntryFormAbility_desc",
        "type": "form",
        "metadata": [
          {
            "name": "ohos.extension.form",
            "resource": "$profile:form_config"
          }
        ]
      }
    ]
  }
}
```

1. 卡片的具体配置信息。在上述FormExtensionAbility的元信息（"metadata"配置项）中，可以指定卡片具体配置信息的资源索引。例如当resource指定为$profile:form_config时，会使用开发视图的resources/base/profile/目录下的form_config.json作为卡片profile配置文件。内部字段结构说明如下表所示。
  表1 卡片profile配置文件

  | 属性名称            | 含义                                                                                                                                                                                                                                    | 数据类型   | 是否可缺省                 |
  | :------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------- | :------------------------- |
  | name                | 表示卡片的类名，字符串最大长度为127字节。                                                                                                                                                                                               | 字符串     | 否                         |
  | description         | 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。                                                                                                                           | 字符串     | 可缺省，缺省为空。         |
  | src                 | 表示卡片对应的UI代码的完整路径。                                                                                                                                                                                                        | 字符串     | 否                         |
  | window              | 用于定义与显示窗口相关的配置。                                                                                                                                                                                                          | 对象       | 可缺省                     |
  | isDefault           | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。- true：默认卡片。- false：非默认卡片。                                                                                                                                    | 布尔值     | 否                         |
  | colorMode           | 表示卡片的主题样式，取值范围如下：- auto：自适应。- dark：深色主题。- light：浅色主题。                                                                                                                                                 | 字符串     | 可缺省，缺省值为“auto”。 |
  | supportDimensions   | 表示卡片支持的外观规格，取值范围：- 1 * 2：表示1行2列的二宫格。- 2 * 2：表示2行2列的四宫格。- 2 * 4：表示2行4列的八宫格。- 4 * 4：表示4行4列的十六宫格。                                                                                | 字符串数组 | 否                         |
  | defaultDimension    | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。                                                                                                                                                                 | 字符串     | 否                         |
  | updateEnabled       | 表示卡片是否支持周期性刷新，取值范围：- true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。- false：表示不支持周期性刷新。                                  | 布尔类型   | 否                         |
  | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。                                                                               | 字符串     | 可缺省，缺省值为“0:0”。  |
  | updateDuration      | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值       | 可缺省，缺省值为“0”。    |
  | formConfigAbility   | 表示卡片的配置跳转链接，采用URI格式。                                                                                                                                                                                                   | 字符串     | 可缺省，缺省值为空。       |
  | formVisibleNotify   | 标识是否允许卡片使用卡片可见性通知。                                                                                                                                                                                                    | 字符串     | 可缺省，缺省值为空。       |
  | metaData            | 表示卡片的自定义信息，包含customizeData数组标签。                                                                                                                                                                                       | 对象       | 可缺省，缺省值为空。       |

  配置示例如下：

```
{
  "forms": [
    {
      "name": "widget",
      "description": "This is a service widget.",
      "src": "./js/widget/pages/index/index",
      "window": {
        "designWidth": 720,
        "autoDesignWidth": true
      },
      "colorMode": "auto",
      "isDefault": true,
      "updateEnabled": true,
      "scheduledUpdateTime": "10:30",
      "updateDuration": 1,
      "defaultDimension": "2*2",
      "supportDimensions": [
        "2*2"
      ]
    }
  ]
}
```

### 卡片信息的持久化

因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息，且卡片管理服务支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。

```
const DATA_STORAGE_PATH = "/data/storage/el2/base/haps/form_store";
async function storeFormInfo(formId: string, formName: string, tempFlag: boolean) {
    // 此处仅对卡片ID：formId，卡片名：formName和是否为临时卡片：tempFlag进行了持久化
    let formInfo = {
        "formName": formName,
        "tempFlag": tempFlag,
        "updateCount": 0
    };
    try {
        const storage = await dataStorage.getStorage(DATA_STORAGE_PATH);
        // put form info
        await storage.put(formId, JSON.stringify(formInfo));
        console.info(`[EntryFormAbility] storeFormInfo, put form info successfully, formId: ${formId}`);
        await storage.flush();
    } catch (err) {
        console.error(`[EntryFormAbility] failed to storeFormInfo, err: ${JSON.stringify(err)}`);
    }
}

export default class EntryFormAbility extends FormExtension {
    ...
    onAddForm(want) {
        console.info('[EntryFormAbility] onAddForm');

        let formId = want.parameters["ohos.extra.param.key.form_identity"];
        let formName = want.parameters["ohos.extra.param.key.form_name"];
        let tempFlag = want.parameters["ohos.extra.param.key.form_temporary"];
        // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用
        // 此接口请根据实际情况实现，具体请参考：FormExtAbility Stage模型卡片实例
        storeFormInfo(formId, formName, tempFlag);

        let obj = {
            "title": "titleOnCreate",
            "detail": "detailOnCreate"
        };
        let formData = formBindingData.createFormBindingData(obj);
        return formData;
    }
}
```

且需要适配onRemoveForm卡片删除通知接口，在其中实现卡片实例数据的删除。

```
const DATA_STORAGE_PATH = "/data/storage/el2/base/haps/form_store";
async function deleteFormInfo(formId: string) {
    try {
        const storage = await dataStorage.getStorage(DATA_STORAGE_PATH);
        // del form info
        await storage.delete(formId);
        console.info(`[EntryFormAbility] deleteFormInfo, del form info successfully, formId: ${formId}`);
        await storage.flush();
    } catch (err) {
        console.error(`[EntryFormAbility] failed to deleteFormInfo, err: ${JSON.stringify(err)}`);
    }
}

...

export default class EntryFormAbility extends FormExtension {
    ...
    onRemoveForm(formId) {
        console.info('[EntryFormAbility] onRemoveForm');
        // 删除之前持久化的卡片实例数据
        // 此接口请根据实际情况实现，具体请参考：FormExtAbility Stage模型卡片实例
        deleteFormInfo(formId);
    }
}
```

具体的持久化方法可以参考[应用数据持久化概述](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/app-data-persistence-overview-0000001505513497-V3)。

需要注意的是，卡片使用方在请求卡片时传递给提供方应用的Want数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片：

* 常态卡片：卡片使用方会持久化的卡片；
* 临时卡片：卡片使用方不会持久化的卡片；

由于临时卡片的数据具有非持久化的特殊性，某些场景例如卡片服务框架死亡重启，此时临时卡片数据在卡片管理服务中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。

### 卡片数据交互

当卡片应用需要更新数据时（如触发了定时更新或定点更新），卡片应用获取最新数据，并调用updateForm()接口主动触发卡片的更新。

```
onUpdateForm(formId) {
    // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新
    console.info('[EntryFormAbility] onUpdateForm');
    let obj = {
        "title": "titleOnUpdate",
        "detail": "detailOnUpdate"
    };
    let formData = formBindingData.createFormBindingData(obj);
    // 调用updateForm接口去更新对应的卡片，仅更新入参中携带的数据信息，其他信息保持不变
    formProvider.updateForm(formId, formData).catch((error) => {
        console.info('[EntryFormAbility] updateForm, error:' + JSON.stringify(error));
    });
}
```

### 开发卡片页面

开发者可以使用类Web范式（HML+CSS+JSON）开发JS卡片页面。生成如下卡片页面，可以这样配置卡片页面文件：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183821.65519250403963174285372359402506:50001231000000:2800:F2735F0C6D67A8D0FCED13225096116ECB13429E12E2452580F313F7448EFD26.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

说明

当前仅支持JS扩展的类Web开发范式来实现卡片的UI。

* HML：使用类Web范式的组件描述卡片的页面信息。
```
<div class="container">
  <stack>
    <div class="container-img">
      <image src="/common/widget.png" class="bg-img"></image>
    </div>
    <div class="container-inner">
      <text class="title">{{title}}</text>
      <text class="detail_text" onclick="routerEvent">{{detail}}</text>
    </div>
  </stack>
</div>
```
* CSS：HML中类Web范式组件的样式信息。
```
.container {
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.bg-img {
  flex-shrink: 0;
  height: 100%;
}

.container-inner {
  flex-direction: column;
  justify-content: flex-end;
  align-items: flex-start;
  height: 100%;
  width: 100%;
  padding: 12px;
}

.title {
  font-size: 19px;
  font-weight: bold;
  color: white;
  text-overflow: ellipsis;
  max-lines: 1;
}

.detail_text {
  font-size: 16px;
  color: white;
  opacity: 0.66;
  text-overflow: ellipsis;
  max-lines: 1;
  margin-top: 6px;
}
```
* JSON：卡片页面中的数据和事件交互。
```
{
  "data": {
    "title": "TitleDefault",
    "detail": "TextDefault"
  },
  "actions": {
    "routerEvent": {
      "action": "router",
      "abilityName": "EntryAbility",
      "params": {
        "message": "add detail"
      }
    }
  }
}
```

### 开发卡片事件

卡片支持为组件设置交互事件（action），包括router事件和message事件，其中router事件用于UIAbility跳转，message事件用于卡片开发人员自定义点击事件。

关键步骤说明如下：

1. 在HML中为组件设置onclick属性，其值对应到JSON文件的actions字段中。
2. 设置router事件：
   * action属性值为"router"。
   * abilityName为跳转目标的UIAbility名（支持跳转FA模型的PageAbility组件和Stage模型的UIAbility组件），如目前DevEco Studio创建的Stage模型的UIAbility默认名为EntryAbility。
   * params为传递给跳转目标UIAbility的自定义参数，可以按需填写。其值可以在目标UIAbility启动时的want中的parameters里获取。如Stage模型MainAbility的onCreate生命周期里的入参want的parameters字段下获取到配置的参数。
3. 设置message事件：
   * action属性值为"message"。
   * params为message事件的用户自定义参数，可以按需填写。其值可以在卡片生命周期函数onFormEvent()中的message里获取。

示例如下。

* HML文件
```
<div class="container">
  <stack>
    <div class="container-img">
      <image src="/common/widget.png" class="bg-img"></image>
    </div>
    <div class="container-inner">
      <text class="title" onclick="routerEvent">{{title}}</text>
      <text class="detail_text" onclick="messageEvent">{{detail}}</text>
    </div>
  </stack>
</div>
```
* CSS文件
```
.container {
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.bg-img {
  flex-shrink: 0;
  height: 100%;
}

.container-inner {
  flex-direction: column;
  justify-content: flex-end;
  align-items: flex-start;
  height: 100%;
  width: 100%;
  padding: 12px;
}

.title {
  font-size: 19px;
  font-weight: bold;
  color: white;
  text-overflow: ellipsis;
  max-lines: 1;
}

.detail_text {
  font-size: 16px;
  color: white;
  opacity: 0.66;
  text-overflow: ellipsis;
  max-lines: 1;
  margin-top: 6px;
}
```
* JSON文件
```
{
  "data": {
    "title": "TitleDefault",
    "detail": "TextDefault"
  },
  "actions": {
    "routerEvent": {
      "action": "router",
      "abilityName": "EntryAbility",
      "params": {
        "info": "router info",
        "message": "router message"
      }
    },
    "messageEvent": {
      "action": "message",
      "params": {
        "detail": "message detail"
      }
    }
  }
}
```
* 在UIAbility中接收router事件并获取参数
```
import UIAbility from '@ohos.app.ability.UIAbility'

export default class EntryAbility extends UIAbility {
    onCreate(want, launchParam) {
        let params = JSON.parse(want.parameters.params);
        // 获取router事件中传递的info参数
        if (params.info === "router info") {
            // do something
            // console.info("router info:" + params.info)
        }
        // 获取router事件中传递的message参数
        if (params.message === "router message") {
            // do something
            // console.info("router message:" + params.message)
        }
    }
    ...
};
```
* 在FormExtensionAbility中接收message事件并获取参数
```
import FormExtension from '@ohos.app.form.FormExtensionAbility';

export default class FormAbility extends FormExtension {
    ...
    onFormEvent(formId, message) {
        // 获取message事件中传递的detail参数
        let msg = JSON.parse(message)
        if (msg.detail === "message detail") {
            // do something
            // console.info("message info:" + msg.detail)
        }
    }
    ...
};
```



# AbilityStage组件容器

更新时间: 2024-01-15 11:54

AbilityStage是一个[Module](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-package-structure-stage-0000001478061425-V3)级别的组件容器，应用的HAP在首次加载时会创建一个AbilityStage实例，可以对该Module进行初始化等操作。

AbilityStage与Module一一对应，即一个Module拥有一个AbilityStage。

DevEco Studio默认工程中未自动生成AbilityStage，如需要使用AbilityStage的能力，可以手动新建一个AbilityStage文件，具体步骤如下。

1. 在工程Module对应的ets目录下，右键选择“New > Directory”，新建一个目录并命名为myabilitystage。
2. 在myabilitystage目录，右键选择“New > TypeScript File”，新建一个TypeScript文件并命名为MyAbilityStage.ts。
3. 打开MyAbilityStage.ts文件，导入AbilityStage的依赖包，自定义类继承AbilityStage并加上需要的生命周期回调，示例中增加了一个onCreate()生命周期回调。
```
import AbilityStage from '@ohos.app.ability.AbilityStage';

export default class MyAbilityStage extends AbilityStage {
  onCreate() {
    // 应用的HAP在首次加载的时，为该Module初始化操作
  }
  onAcceptWant(want) {
    // 仅specified模式下触发
    return "MyAbilityStage";
  }
}
```
4. 在[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)中，通过配置srcEntry参数来指定模块对应的代码路径，以作为HAP加载的入口。
```
{
  "module": {
    "name": "entry",
    "type": "entry",
    "srcEntry": "./ets/myabilitystage/MyAbilityStage.ts",
    ...
  }
}
```

[AbilityStage](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3)拥有[onCreate()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageoncreate)生命周期回调和[onAcceptWant()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageonacceptwant)、[onConfigurationUpdated()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageonconfigurationupdate)、[onMemoryLevel()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageonmemorylevel)事件回调。

* [onCreate()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageoncreate)生命周期回调：在开始加载对应Module的第一个UIAbility实例之前会先创建AbilityStage，并在AbilityStage创建完成之后执行其onCreate()生命周期回调。AbilityStage模块提供在Module加载的时候，通知开发者，可以在此进行该Module的初始化（如资源预加载，线程创建等）能力。
* [onAcceptWant()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageonacceptwant)事件回调：UIAbility[指定实例模式（specified）](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-launch-type-0000001428061476-V3#ZH-CN_TOPIC_0000001523489150__specified%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F)启动时候触发的事件回调，具体使用请参见[UIAbility启动模式综述](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-launch-type-0000001428061476-V3)。
* [onConfigurationUpdated()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageonconfigurationupdate)事件回调：当系统全局配置发生变更时触发的事件，系统语言、深浅色等，配置项目前均定义在[Configuration](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-configuration-0000001493424320-V3)类中。
* [onMemoryLevel()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-abilitystage-0000001493424312-V3#ZH-CN_TOPIC_0000001574088265__abilitystageonmemorylevel)事件回调：当系统调整内存时触发的事件。

应用被切换到后台时，系统会将在后台的应用保留在缓存中。即使应用处于缓存中，也会影响系统整体性能。当系统资源不足时，系统会通过多种方式从应用中回收内存，必要时会完全停止应用，从而释放内存用于执行关键任务。为了进一步保持系统内存的平衡，避免系统停止用户的应用进程，可以在AbilityStage中的onMemoryLevel()生命周期回调中订阅系统内存的变化情况，释放不必要的资源。

```
import AbilityStage from '@ohos.app.ability.AbilityStage';

export default class MyAbilityStage extends AbilityStage {
    onMemoryLevel(level) {
        // 根据系统可用内存的变化情况，释放不必要的内存
    }
}
```



# 应用上下文Context

更新时间: 2024-01-15 12:18

## 概述

[Context](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-context-0000001427744988-V3)是应用中对象的上下文，其提供了应用的一些基础信息，例如resourceManager（资源管理）、applicationInfo（当前应用信息）、dir（应用开发路径）、area（文件分区）等，以及应用的一些基本方法，例如createBundleContext()、getApplicationContext()等。UIAbility组件和各种ExtensionAbility派生类组件都有各自不同的Context类。分别有基类Context、ApplicationContext、AbilityStageContext、UIAbilityContext、ExtensionContext、ServiceExtensionContext等Context。

* 各类Context的继承关系
  ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183823.69650744555189217956730374112938:50001231000000:2800:DFACD66BE423434F31418A78C8022AACC830C2DFC4CAD22B1CEEF9BD9DA7A2BC.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)
* 各类Context的持有关系
  ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183823.17427505326590215569510479309825:50001231000000:2800:A91B2D987EB20AE437A16147C7194992F2DD80DDB4035104040B1753EDFA3E75.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)
* 各类Context的获取方式
  * 获取[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)。每个UIAbility中都包含了一个Context属性，提供操作Ability、获取Ability的配置信息、应用向用户申请授权等能力。
```
import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {
    onCreate(want, launchParam) {
        let uiAbilityContext = this.context;
        // ...
    }
}
```
  * 获取[AbilityStageContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-abilitystagecontext-0000001478181577-V3)。Module级别的Context，和基类Context相比，额外提供HapModuleInfo、Configuration等信息。
```
import AbilityStage from "@ohos.app.ability.AbilityStage";
export default class MyAbilityStage extends AbilityStage {
    onCreate() {
        let abilityStageContext = this.context;
        // ...
    }
}
```
  * 获取[ApplicationContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-applicationcontext-0000001477981357-V3)。应用级别的Context。ApplicationContext在基类Context的基础上提供了订阅应用内Ability的生命周期的变化、订阅系统内存变化和订阅应用内系统环境的变化的能力，在UIAbility、ExtensionAbility、AbilityStage中均可以获取。
```
import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {
    onCreate(want, launchParam) {
        let applicationContext = this.context.getApplicationContext();
        // ...
    }
}
```

## Context的典型使用场景

本章节通过如下典型场景来介绍Context的用法：

* [获取应用文件路径](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-context-stage-0000001427744560-V3#ZH-CN_TOPIC_0000001574128741__%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%B7%AF%E5%BE%84)
* [获取和修改加密分区](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-context-stage-0000001427744560-V3#ZH-CN_TOPIC_0000001574128741__%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BF%AE%E6%94%B9%E5%8A%A0%E5%AF%86%E5%88%86%E5%8C%BA)
* [创建其他应用或其他Module的Context](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-context-stage-0000001427744560-V3#ZH-CN_TOPIC_0000001574128741__%E5%88%9B%E5%BB%BA%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E6%88%96%E5%85%B6%E4%BB%96module%E7%9A%84context)
* [订阅进程内Ability生命周期变化](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-context-stage-0000001427744560-V3#ZH-CN_TOPIC_0000001574128741__%E8%AE%A2%E9%98%85%E8%BF%9B%E7%A8%8B%E5%86%85ability%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%98%E5%8C%96)

### 获取应用文件路径

基类[Context](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-app-context-0000001478181573-V3)提供了获取应用文件路径的能力，ApplicationContext、AbilityStageContext、UIAbilityContext和ExtensionContext均继承该能力。应用文件路径属于应用沙箱路径，具体请参见[应用沙箱目录](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/app-sandbox-directory-0000001491863498-V3)。

上述各类Context获取的应用文件路径有所不同。

* 通过ApplicationContext获取应用级别的应用文件路径，此路径是应用全局信息推荐的存放路径，这些文件会跟随应用的卸载而删除。| 属性                | 路径                                    |
  | :------------------ | :-------------------------------------- |
  | bundleCodeDir       | <路径前缀>/el1/bundle/                  |
  | cacheDir            | <路径前缀>/<加密等级>/base/cache/       |
  | filesDir            | <路径前缀>/<加密等级>/base/files/       |
  | preferencesDir      | <路径前缀>/<加密等级>/base/preferences/ |
  | tempDir             | <路径前缀>/<加密等级>/base/temp/        |
  | databaseDir         | <路径前缀>/<加密等级>/database/         |
  | distributedFilesDir | <路径前缀>/el2/distributedFiles/        |
* 通过AbilityStageContext、UIAbilityContext、ExtensionContext获取HAP级别的应用文件路径。此路径是HAP相关信息推荐的存放路径，这些文件会跟随HAP的卸载而删除，但不会影响应用级别路径的文件，除非该应用的HAP已全部卸载。| 属性                | 路径                                                           |
  | :------------------ | :------------------------------------------------------------- |
  | bundleCodeDir       | <路径前缀>/el1/bundle/                                         |
  | cacheDir            | <路径前缀>/<加密等级>/base/haps/`<module-name>`/cache/       |
  | filesDir            | <路径前缀>/<加密等级>/base/haps/`<module-name>`/files/       |
  | preferencesDir      | <路径前缀>/<加密等级>/base/haps/`<module-name>`/preferences/ |
  | tempDir             | <路径前缀>/<加密等级>/base/haps/`<module-name>`/temp/        |
  | databaseDir         | <路径前缀>/<加密等级>/database/`<module-name>`/              |
  | distributedFilesDir | <路径前缀>/el2/distributedFiles/`<module-name>`/             |

示例代码如下。

```
import UIAbility from '@ohos.app.ability.UIAbility';

export default class EntryAbility extends UIAbility {
    onCreate(want, launchParam) {
        let cacheDir = this.context.cacheDir;
        let tempDir = this.context.tempDir;
        let filesDir = this.context.filesDir;
        let databaseDir = this.context.databaseDir;
        let bundleCodeDir = this.context.bundleCodeDir;
        let distributedFilesDir = this.context.distributedFilesDir;
        let preferencesDir = this.context.preferencesDir;
        // ...
    }
}
```

### 获取和修改加密分区

上一个场景中，引入了加密等级的概念，通过对[Context的area属性](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-context-0000001427744988-V3)的读写来实现获取和设置当前加密分区，支持如下两种加密等级：

* AreaMode.EL1：设备级加密区，设备开机后可访问的数据区。
* AreaMode.EL2：用户级加密区，设备开机，首次输入密码后才能够访问的数据区。

```
import UIAbility from '@ohos.app.ability.UIAbility';

export default class EntryAbility extends UIAbility {
    onCreate(want, launchParam) {
        // 存储普通信息前，切换到EL1设备级加密
        if (this.context.area === 1) { // 获取area
            this.context.area = 0;     // 修改area
        }
        // 存储普通信息

        // 存储敏感信息前，切换到EL2用户级加密
        if (this.context.area === 0) { // 获取area
            this.context.area = 1;     // 修改area
        }
        // 存储敏感信息
    }
}
```

### 创建其他应用或其他Module的Context

基类Context提供创建其他应用或其他Module的Context的方法为[createModuleContext(moduleName:string)](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-context-0000001427744988-V3#ZH-CN_TOPIC_0000001523648906__contextcreatemodulecontext)，创建其他应用或者其他Module的Context，从而通过该Context获取相应的资源信息（例如获取其他Module的[获取应用开发路径](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-context-stage-0000001427744560-V3#ZH-CN_TOPIC_0000001574128741__%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%B7%AF%E5%BE%84)信息）。

调用createModuleContext(moduleName:string)方法，获取本应用中其他Module的Context。获取到其他Module的Context之后，即可获取到相应Module的资源信息。

```
import UIAbility from '@ohos.app.ability.UIAbility';

export default class EntryAbility extends UIAbility {
    onCreate(want, launchParam) {
        let moduleName2 = "module1";
        let context2 = this.context.createModuleContext(moduleName2);
        // ...
    }
}
```

### 订阅进程内Ability生命周期变化

在应用内的DFX统计场景，如需要统计对应页面停留时间和访问频率等信息，可以使用订阅进程内Ability生命周期变化功能。

在进程内Ability生命周期变化时，如创建、可见/不可见、获焦/失焦、销毁等，会触发进入相应的回调，其中返回的此次注册监听生命周期的ID（每次注册该ID会自增+1，当超过监听上限数量2^63-1时，返回-1），以在[UIAbilityContext](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-inner-application-uiabilitycontext-0000001478341321-V3)中使用为例进行说明。

```
import UIAbility from '@ohos.app.ability.UIAbility';
import Window from '@ohos.window';

const TAG: string = "[Example].[Entry].[EntryAbility]";

export default class EntryAbility extends UIAbility {
    lifecycleId: number;

    onCreate(want, launchParam) {
        let abilityLifecycleCallback = {
            onAbilityCreate(ability) {
                console.info(TAG, "onAbilityCreate ability:" + JSON.stringify(ability));
            },
            onWindowStageCreate(ability, windowStage) {
                console.info(TAG, "onWindowStageCreate ability:" + JSON.stringify(ability));
                console.info(TAG, "onWindowStageCreate windowStage:" + JSON.stringify(windowStage));
            },
            onWindowStageActive(ability, windowStage) {
                console.info(TAG, "onWindowStageActive ability:" + JSON.stringify(ability));
                console.info(TAG, "onWindowStageActive windowStage:" + JSON.stringify(windowStage));
            },
            onWindowStageInactive(ability, windowStage) {
                console.info(TAG, "onWindowStageInactive ability:" + JSON.stringify(ability));
                console.info(TAG, "onWindowStageInactive windowStage:" + JSON.stringify(windowStage));
            },
            onWindowStageDestroy(ability, windowStage) {
                console.info(TAG, "onWindowStageDestroy ability:" + JSON.stringify(ability));
                console.info(TAG, "onWindowStageDestroy windowStage:" + JSON.stringify(windowStage));
            },
            onAbilityDestroy(ability) {
                console.info(TAG, "onAbilityDestroy ability:" + JSON.stringify(ability));
            },
            onAbilityForeground(ability) {
                console.info(TAG, "onAbilityForeground ability:" + JSON.stringify(ability));
            },
            onAbilityBackground(ability) {
                console.info(TAG, "onAbilityBackground ability:" + JSON.stringify(ability));
            },
            onAbilityContinue(ability) {
                console.info(TAG, "onAbilityContinue ability:" + JSON.stringify(ability));
            }
        }
        // 1. 通过context属性获取applicationContext
        let applicationContext = this.context.getApplicationContext();
        // 2. 通过applicationContext注册监听应用内生命周期
        this.lifecycleId = applicationContext.on("abilityLifecycle", abilityLifecycleCallback);
        console.info(TAG, "register callback number: " + JSON.stringify(this.lifecycleId));
    }

    onDestroy() {
        let applicationContext = this.context.getApplicationContext();
        applicationContext.off("abilityLifecycle", this.lifecycleId, (error, data) => {
            console.info(TAG, "unregister callback success, err: " + JSON.stringify(error));
        });
    }
}
```



# Want概述

更新时间: 2024-01-15 12:19

## Want的定义与用途

[Want](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-want-0000001493584192-V3)是对象间信息传递的载体，可以用于应用组件间的信息传递。其使用场景之一是作为startAbility()的参数，包含了指定的启动目标以及启动时需携带的相关数据，如bundleName和abilityName字段分别指明目标Ability所在应用的包名以及对应包内的Ability名称。当UIAbilityA启动UIAbilityB并需要传入一些数据给UIAbilityB时，Want可以作为一个载体将数据传给UIAbilityB。

图1 Want用法示意

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183824.82848454518977553435136386372777:50001231000000:2800:54F3952414D6836C8235D2D3AAFA6C41D061A3FC3031711FFF6DDC7B20291A5A.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

## Want的类型

*  显式Want ：在启动Ability时指定了abilityName和bundleName的Want称为显式Want。
  当有明确处理请求的对象时，通过提供目标Ability所在应用的包名信息（bundleName），并在Want内指定abilityName便可启动目标Ability。显式Want通常用于在当前应用开发中启动某个已知的Ability。参数说明参见[Want参数说明](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/want-overview-0000001478340877-V3#ZH-CN_TOPIC_0000001574088785__Want%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E)。

```
let wantInfo = {
    deviceId: '', // deviceId为空表示本设备
    bundleName: 'com.example.myapplication',
    abilityName: 'FuncAbility',
}
```

* 隐式Want ：在启动UIAbility时未指定abilityName的Want称为隐式Want。
  当请求处理的对象不明确时，希望在当前应用中使用其他应用提供的某个能力（通过[skills标签](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3#ZH-CN_TOPIC_0000001573929365__skills%E6%A0%87%E7%AD%BE)定义），而不关心提供该能力的具体应用，可以使用隐式Want。例如使用隐式Want描述需要打开一个链接的请求，而不关心通过具体哪个应用打开，系统将匹配声明支持该请求的所有应用。

```
let wantInfo = {
    // uncomment line below if wish to implicitly query only in the specific bundle.
    // bundleName: 'com.example.myapplication',
    action: 'ohos.want.action.search',
    // entities can be omitted
    entities: [ 'entity.system.browsable' ],
    uri: 'https://www.test.com:8080/query/student',
    type: 'text/plain',
};
```

  说明

  根据系统中待匹配Ability的匹配情况不同，使用隐式Want启动Ability时会出现以下三种情况。* 未匹配到满足条件的Ability：启动失败。

* 匹配到一个满足条件的Ability：直接启动该Ability。
* 匹配到多个满足条件的Ability（UIAbility）：弹出选择框让用户选择。

## Want参数说明

| 名称                                                                                                                                                                           | 读写属性 | 类型                 | 必填 | 描述                                                                                                                                                                                                                                                                                                                                    |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------- | :--------------------- | :----- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| deviceId                                                                                                                                                                       | 只读     | string               | 否   | 表示目标Ability所在设备ID。如果未设置该字段，则表明本设备。                                                                                                                                                                                                                                                                             |
| bundleName                                                                                                                                                                     | 只读     | string               | 否   | 表示目标Ability所在应用名称。                                                                                                                                                                                                                                                                                                           |
| moduleName                                                                                                                                                                     | 只读     | string               | 否   | 表示目标Ability所属的模块名称。                                                                                                                                                                                                                                                                                                         |
| abilityName                                                                                                                                                                    | 只读     | string               | 否   | 表示目标Ability名称。如果未设置该字段，则该Want为隐式。如果在Want中同时指定了bundleName，moduleName和abilityName，则Want可以直接匹配到指定的Ability。                                                                                                                                                                                   |
| uri                                                                                                                                                                            | 只读     | string               | 否   | 表示携带的数据，一般配合type使用，指明待处理的数据类型。如果在Want中指定了uri，则Want将匹配指定的Uri信息，包括scheme, schemeSpecificPart, authority和path信息。                                                                                                                                                                         |
| type                                                                                                                                                                           | 只读     | string               | 否   | 表示携带数据类型，使用MIME类型规范。例如："text/plain"、"image/*"等。                                                                                                                                                                                                                                                                   |
| [action](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3)                                                | 只读     | string               | 否   | 表示要执行的通用操作（如：查看、分享、应用详情）。在隐式Want中，您可定义该字段，配合uri或parameters来表示对数据要执行的操作。如打开，查看该uri数据。例如，当uri为一段网址，action为ohos.want.action.viewData则表示匹配可查看该网址的Ability。                                                                                           |
| [entities](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3)                                              | 只读     | Array`<string>`        | 否   | 表示目标Ability额外的类别信息（如：浏览器，视频播放器），在隐式Want中是对action的补充。在隐式Want中，您可定义该字段，来过滤匹配UIAbility类别，如必须是浏览器。例如，在action字段的举例中，可存在多个应用声明了支持查看网址的操作，其中有应用为普通社交应用，有的为浏览器应用，您可通过entity.system.browsable过滤掉非浏览器的其他应用。 |
| [flags](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3#ZH-CN_TOPIC_0000001574088649__wantconstantflags) | 只读     | number               | 否   | 表示处理Want的方式。例如通过wantConstant.Flags.FLAG_ABILITY_CONTINUATION表示是否以设备间迁移方式启动Ability。                                                                                                                                                                                                                           |
| parameters                                                                                                                                                                     | 只读     | {[key: string]: any} | 否   | 此参数用于传递自定义数据，通过用户自定义的键值对进行数据填充，具体支持的数据类型如[Want API](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-app-ability-want-0000001493584192-V3)所示。                                                                                                                   |



# 显式Want与隐式Want匹配规则

更新时间: 2024-01-15 12:20

在启动目标Ability时，会通过显式Want和隐式Want进行目标Ability的匹配，这里说的匹配规则就是调用方Want中设置的参数如何与目标Ability声明的配置文件进行匹配。

* 显式Want匹配原理
  | 名称        | 类型                 | 匹配项 | 必选 | 规则                                                                        |
  | :---------- | :------------------- | :----- | :--- | :-------------------------------------------------------------------------- |
  | deviceId    | string               | 是     | 否   | 留空将仅匹配本设备内Ability。                                               |
  | bundleName  | string               | 是     | 是   | 如果指定abilityName，而不指定bundleName，则匹配失败。                       |
  | moduleName  | string               | 是     | 否   | 留空时当同一个应用内存在多个模块且模块间存在重名Ability，将默认匹配第一个。 |
  | abilityName | string               | 是     | 是   | 该字段必须设置表示显式匹配。                                                |
  | uri         | string               | 否     | 否   | 系统匹配时将忽略该参数，但仍可作为参数传递给目标Ability。                   |
  | type        | string               | 否     | 否   | 系统匹配时将忽略该参数，但仍可作为参数传递给目标Ability。                   |
  | action      | string               | 否     | 否   | 系统匹配时将忽略该参数，但仍可作为参数传递给目标Ability。                   |
  | entities    | Array`<string>`    | 否     | 否   | 系统匹配时将忽略该参数，但仍可作为参数传递给目标Ability。                   |
  | flags       | number               | 否     | 否   | 不参与匹配，直接传递给系统处理，一般用来设置运行态信息，例如URI数据授权等。 |
  | parameters  | {[key: string]: any} | 否     | 否   | 不参与匹配，应用自定义数据将直接传递给目标Ability。                         |
* 隐式Want匹配原理
  | 名称        | 类型                 | 匹配项 | 必选 | 规则                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
  | :---------- | :------------------- | :----- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
  | deviceId    | string               | 是     | 否   | 跨设备目前不支持隐式调用。说明当前版本暂不支持跨设备能力。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
  | abilityName | string               | 否     | 否   | 该字段必须留空表示隐式匹配。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
  | bundleName  | string               | 是     | 否   | - 声明bundleName时，隐式搜索将仅限于对应应用包内。- 声明bundleName与moduleName时，隐式搜索将仅限于对应应用的对应Module内。- 单独声明moduleName时，该字段无效。- 同时声明bundleName与moduleName时，隐式搜索将仅限于对应应用包内的对应模块内。这些字段将用来隐式匹配，具体规则可参考[隐式Want匹配原理详解](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/explicit-implicit-want-mappings-0000001478061453-V3#ZH-CN_TOPIC_0000001523808814__%E9%9A%90%E5%BC%8Fwant%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3)。 |
  | moduleName  | string               | 是     | 否   | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
  | uri         | string               | 是     | 否   | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
  | type        | string               | 是     | 否   | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
  | action      | string               | 是     | 否   | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
  | entities    | Array`<string>`    | 是     | 否   | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
  | flags       | number               | 否     | 否   | 不参与匹配，直接传递给系统处理，一般用来设置运行态信息，例如URI数据授权等。                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
  | parameters  | {[key: string]: any} | 否     | 否   | 不参与匹配，应用自定义数据将直接传递给目标Ability。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |

## 隐式Want匹配原理详解

从隐式Want的定义，可得知：

* 调用方传入的want参数，表明调用方需要执行的操作，并提供相关数据以及其他应用类型限制。
* 待匹配Ability的skills配置，声明其具备的能力（[module.json5配置文件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3)中的[skills标签](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/module-configuration-file-0000001427744540-V3#ZH-CN_TOPIC_0000001573929365__skills%E6%A0%87%E7%AD%BE)参数）。

系统将调用方传入的want参数（包含action、entities、uri和type属性）与已安装待匹配的应用Ability的skills配置（包含actions、entities、uris和type属性）依次进行匹配。当四个属性匹配均通过，则此应用才会被应用选择器展示给用户进行选择。

### want参数的action匹配规则

将调用方传入的want参数的action与待匹配Ability的skills配置中的actions进行匹配。

* 调用方传入的want参数的action为空，待匹配Ability的skills配置中的actions为空，则action匹配失败。
* 调用方传入的want参数的action不为空，待匹配Ability的skills配置中的actions为空，则action匹配失败。
* 调用方传入的want参数的action为空，待匹配Ability的skills配置中的actions不为空，则action匹配成功。
* 调用方传入的want参数的action不为空，待匹配Ability的skills配置中的actions不为空且包含调用方传入的want参数的action，则action匹配成功。
* 调用方传入的want参数的action不为空，待匹配Ability的skills配置中的actions不为空且不包含调用方传入的want参数的action，则action匹配失败。
  图1 want参数的action匹配规则
  ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183825.05556818448290571701136720241980:50001231000000:2800:48E1E790EC99B8B311043A9B7A7876289444B900C0AC6FE132E42E5CAA4DD46D.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true "点击放大")

### want参数的entities匹配规则

将调用方传入的want参数的entities与待匹配Ability的skills配置中的entities进行匹配。

* 调用方传入的want参数的entities为空，待匹配Ability的skills配置中的entities不为空，则entities匹配成功。
* 调用方传入的want参数的entities为空，待匹配Ability的skills配置中的entities为空，则entities匹配成功。
* 调用方传入的want参数的entities不为空，待匹配Ability的skills配置中的entities为空，则entities匹配失败。
* 调用方传入的want参数的entities不为空，待匹配Ability的skills配置中的entities不为空且包含调用方传入的want参数的entities，则entities匹配成功。
* 调用方传入的want参数的entities不为空，待匹配Ability的skills配置中的entities不为空且不完全包含调用方传入的want参数的entities，则entities匹配失败。
  图2 want参数的entities匹配规则
  ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183825.14961286642525082148631424192521:50001231000000:2800:3E1CAE69C64CC1C6286F82FB8AC4A07884ED903EDC1F6F90B3E0CC55EC9DC8F1.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

### want参数的uri和type匹配规则

调用方传入的want参数中设置uri和type参数发起组件启动请求，系统会遍历当前系统已安装的组件列表，并逐个匹配待匹配Ability的skills配置中的uris数组，如果待匹配Ability的skills配置中的uris数组中只要有一个可以匹配调用方传入的want参数中设置的uri和type即为匹配成功。

图3 want参数中uri和type皆不为空时的匹配规则

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183825.57623993944196713049132599838578:50001231000000:2800:6AFE0E65F67BE6AEA59DB08A059EE47F49788269829F0F677AA85D9273B3BD9D.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

实际应用中，uri和type共存在四种情况，下面将讲解四种情况的具体匹配规则：

* 调用方传入的want参数的uri和type都为空。
  1. 如果待匹配Ability的skills配置中的uris数组为空，匹配成功。
  2. 如果待匹配Ability的skills配置中的uris数组中存在uri的scheme和type都为空的元素，匹配成功。
  3. 除以上两种情况，其他情况均为匹配失败。
* 调用方传入的want参数的uri不为空，type为空。
  1. 如果待匹配Ability的skills配置中的uris数组为空，匹配失败。
  2. 如果待匹配Ability的skills配置中的uris数组存在一条数据[uri匹配](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/explicit-implicit-want-mappings-0000001478061453-V3#ZH-CN_TOPIC_0000001523808814__uri%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99)成功且type为空，则匹配成功，否则匹配失败。
* 调用方传入的want参数的uri为空，type不为空。
  1. 如果待匹配Ability的skills配置中的uris数组为空，匹配失败。
  2. 如果待匹配Ability的skills配置中的uris数组存在一条数据uri的scheme为空且[type匹配](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/explicit-implicit-want-mappings-0000001478061453-V3#ZH-CN_TOPIC_0000001523808814__type%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99)成功，则匹配成功，否则匹配失败。
* 调用方传入的want参数的uri和type都不为空，如图3所示。
  1. 如果待匹配Ability的skills配置中的uris数组为空，匹配失败。
  2. 如果待匹配Ability的skills配置中的uris数组存在一条数据[uri匹配](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/explicit-implicit-want-mappings-0000001478061453-V3#ZH-CN_TOPIC_0000001523808814__uri%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99)和[type匹配](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/explicit-implicit-want-mappings-0000001478061453-V3#ZH-CN_TOPIC_0000001523808814__type%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99)需要均匹配成功，则匹配成功，否则匹配失败。

下图为了简化描述，称want中传入的uri为w_uri，称want中传入的type为w_type, 待匹配Ability的skills配置中uris为s_uris，其中每个元素为s_uri；按自上而下顺序匹配。

图4 want参数中uri和type的具体匹配规则

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183825.16328218349453265792798060724712:50001231000000:2800:592712E27301558D1BD8C25BF9AAAF2743051652DB32B54C529276DD04459EDF.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

### uri匹配规则

这里为了简化描述，称want中传入的uri为w_uri，待匹配Ability的skills配置中uri为s_uri，具体的匹配规则如下：

* 如果s_uri的scheme为空，当w_uri为空时匹配成功，否则匹配失败；
* 如果s_uri的host为空，当w_uri和s_uri的scheme相同时匹配成功，否则匹配失败；
* 如果s_uri的path、pathStartWith和pathRegex都为空，当w_uri和s_uri完全相同时匹配成功，否则匹配失败；
* 如果s_uri的path不为空，当w_uri和s_uri全路径表达式相同时匹配成功，否则继续进行pathStartWith的匹配；
* 如果s_uri的pathStartWith不为空，当w_uri包含s_uri前缀表达式时匹配成功，否则继续进行pathRegex的匹配；
* 如果s_uri的pathRegex不为空，当w_uri满足s_uri正则表达式时匹配成功，否则匹配失败；

说明

待匹配Ability的skills配置的uris中scheme、host、port、path、pathStartWith和pathRegex属性拼接，如果依次声明了path、pathStartWith和pathRegex属性时，uris将分别拼接为如下三种表达式：

* 全路径表达式 ：scheme://host:port/path
* 前缀表达式 ：scheme://host:port/pathStartWith
* 正则表达式 ：scheme://host:port/pathRegex

### type匹配规则

说明

此小节所述的type匹配规则的适用性需建立在want参数内type不为空的基础上。当want参数内type为空时请参考[want参数的uri和type匹配规则](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/explicit-implicit-want-mappings-0000001478061453-V3#ZH-CN_TOPIC_0000001523808814__want%E5%8F%82%E6%95%B0%E7%9A%84uri%E5%92%8Ctype%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99)。

这里为了简化描述，称want中传入的uri为w_type，待匹配Ability的skills数组中uris的type数据为s_type，具体的匹配规则如下：

* 如果s_type为空，则匹配失败。
* 如果s_type或者w_type为通配符"*/*"，则匹配成功。
* 如果s_type最后一个字符为通配符'*'，如"prefixType/*"，则当w_type包含"prefixType/"时匹配成功，否则匹配失败。
* 如果w_type最后一个字符为通配符'*'，如"prefixType/*"，则当s_type包含"prefixType/"时匹配成功，否则匹配失败。



# 常见action与entities

更新时间: 2024-01-15 11:54

[action](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3#ZH-CN_TOPIC_0000001574088649__wantconstantaction)：表示调用方要执行的通用操作（如查看、分享、应用详情）。在隐式Want中，您可定义该字段，配合uri或parameters来表示对数据要执行的操作。如打开，查看该uri数据。例如，当uri为一段网址，action为ohos.want.action.viewData则表示匹配可查看该网址的Ability。在Want内声明action字段表示希望被调用方应用支持声明的操作。在被调用方应用配置文件skills字段内声明actions表示该应用支持声明操作。

常见action

* ACTION_HOME：启动应用入口组件的动作，需要和ENTITY_HOME配合使用；系统桌面应用图标就是显式的入口组件，点击也是启动入口组件；入口组件可以配置多个。
* ACTION_CHOOSE：选择本地资源数据，例如联系人、相册等；系统一般对不同类型的数据有对应的Picker应用，例如联系人和图库。
* ACTION_VIEW_DATA：查看数据，当使用网址uri时，则表示显示该网址对应的内容。
* ACTION_VIEW_MULTIPLE_DATA：发送多个数据记录的操作。

[entities](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-ability-wantconstant-0000001544583997-V3#ZH-CN_TOPIC_0000001574088649__wantconstantentity)：表示目标Ability的类别信息（如浏览器、视频播放器），在隐式Want中是对action的补充。在隐式Want中，开发者可定义该字段，来过滤匹配应用的类别，例如必须是浏览器。在Want内声明entities字段表示希望被调用方应用属于声明的类别。在被调用方应用配置文件skills字段内声明entites表示该应用支持的类别。

常用entities

* ENTITY_DEFAULT：默认类别无实际意义。
* ENTITY_HOME：主屏幕有图标点击入口类别。
* ENTITY_BROWSABLE：指示浏览器类别。



# 使用显式Want启动Ability

更新时间: 2024-01-15 12:22

在应用使用场景中，当用户点击某个按钮时，应用经常需要拉起指定UIAbility组件来完成某些特定任务。下面介绍如何通过显式Want拉起应用内一个指定UIAbility组件。

## 开发步骤

1. Stage模型工程内，创建一个Ability（此示例内命名为callerAbility）与相应Page（此示例中名为Index.ets），并在callerAbility.ts文件内的onWindowStageCreate函数内通过windowStage.loadContent()方法将两者绑定。

```
// ...
    // callerAbility.ts
    onWindowStageCreate(windowStage) {
        // Main window is created, set main page for this ability
        console.info('[Demo] EntryAbility onWindowStageCreate')
        // Bind callerAbility with a paged named Index
        windowStage.loadContent('pages/Index')
    }
// ...
```
2. 同上方法再创建一个Ability，此示例内命名为“calleeAbility”。
3. 在callerAbility的“Index.ets”页面内新增一个按钮。
```
// ...
  build() {
    Row() {
      Column() {
        Text('hello')
        .fontSize(50)
        .fontWeight(FontWeight.Bold)
        // A new button with will call explicitStartAbility() when clicked.
        Button("CLICKME")
        .onClick(this.explicitStartAbility) // explicitStartAbility见下面示例代码
        // ...
      }
      .width('100%')
    }
    .height('100%')
  }
// ...
```
4. 补充相对应的onClick方法，并使用显式Want在方法内启动calleeAbility。bundleName字段可在工程AppScope>app.json5文件内获取；abilityName可在对应模块内的“yourModuleName > src > main > module.json5”文件查看。
```
import common from '@ohos.app.ability.common';

// ...
  async explicitStartAbility() {
    try {
      // Explicit want with abilityName specified.
      let want = {
        deviceId: "",
        bundleName: "com.example.myapplication",
        abilityName: "calleeAbility"
      };
      let context = getContext(this) as common.UIAbilityContext;
      await context.startAbility(want);
      console.info(`explicit start ability succeed`);
    } catch (error) {
      console.info(`explicit start ability failed with ${error.code}`);
    }
  }
// ...
```
5. 至此，当您点击CLICKME按钮时，应看到页面的跳转。
   ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183826.08618255257373253140649771538552:50001231000000:2800:1927A953484A60A65883B0B7ABF89A082115994BE08A96D7AC2E04E41EA92464.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)



# 使用隐式Want打开网址

更新时间: 2024-01-15 12:22

## 前提条件

设备上安装了一个或多个浏览器。

浏览器应用中通过module.json5配置如下：

```
"skills": [
  {
    "entities": [
      "entity.system.browsable"
      // ...
    ],
    "actions": [
        "ohos.want.action.viewData"
        // ...
    ],
    "uris": [
      {
        "scheme": "https",
        "host": "www.test.com",
        "port": "8080",
        // prefix matching
        "pathStartWith": "query",
        "type": "text/*"
      },
      {
        "scheme": "http",
        // ...
      }
      // ...
    ]
  },
]
```

## 开发步骤

1. 在自定义函数implicitStartAbility内使用隐式Want启动Ability。

```
    async implicitStartAbility() {
        try {
            let want = {
                // uncomment line below if wish to implicitly query only in the specific bundle.
                // bundleName: "com.example.myapplication",
                "action": "ohos.want.action.viewData",
                // entities can be omitted.
                "entities": [ "entity.system.browsable" ],
                "uri": "https://www.test.com:8080/query/student",
                "type": "text/plain"
            }
            let context = getContext(this) as common.UIAbilityContext;
            await context.startAbility(want)
            console.info(`explicit start ability succeed`)
        } catch (error) {
            console.info(`explicit start ability failed with ${error.code}`)
        }
     }
```

  匹配过程如下：
  a. want内action不为空，且被skills内action包括，匹配成功。
  b. want内entities不为空，且被skills内entities包括，匹配成功。
  c. skills内uris拼接为[https://www.test.com:8080/query\](https://www.test. com:8080/query/)* (*为通配符)包含want内uri，匹配成功。
  d. want内type不为空，且被skills内type包含，匹配成功。
2. 当有多个匹配应用时，会被应用选择器展示给用户进行选择。
  ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183826.33983711079055035785122152254165:50001231000000:2800:91CDA924E084855AC790113BE5E0BBFE211CD60D9F067A191EA29B1C01318EA5.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)



# 应用间使用Want分享数据

更新时间: 2024-01-15 12:22

在应用使用场景中，用户经常需要将一个应用内的数据（如文字、图片等）分享至另一个应用内继续操作。下面以PDF文件分享为例，介绍应用间使用Want分享数据的方法。

## 前提条件

1. 数据分享涉及2个UIAbility组件（分享方和被分享方）和1个系统部件（应用选择框）。当分享方通过startAbility接口发起数据分享后，将拉起应用选择框。其将隐式匹配并展示所有支持接受分享数据类型的应用，由用户主动选取，并由系统拉起点击应用完成数据的分享。

1. 在本章节中，将继续以按钮形式来触发分享，实际开发场景中并不局限于此，此章节着重讲解分享时Want的配置。
2. 本章节涉及的action：
   * ACTION_SELECT （ohos.want.action.select）：指示显示应用程序选择框的操作。用于拉起应用选择框。
   * ACTION_SEND_DATA （ohos.want.action.sendData）：指示发送单个数据记录的操作。用于传递数据至分享方。

## 开发步骤

* 分享方

1. Stage模型下经常会遇到需要分享文件的场景，在这种场景下我们需要使用[文件描述符（FD）](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-fileio-0000001478181641-V3#ZH-CN_TOPIC_0000001523808486__fileioopensync)来传递文件。此示例中，默认已获取分享文件的路径。

```
import fileIO from '@ohos.fileio';

// let path = ...
// file open where path is a variable contains the file path.
let fileFd = fileIO.openSync(path, 0o102, 0o666);
```
2. 在前提条件中介绍了分享的流程。分享方需先拉起应用选择框，并将数据分享给应用选择框，并由应用选择框代理传递至被分享方，完成分享。因此分享方的Want需使用2层嵌套，在第1层中使用隐式Want并配合“ohos.want.action.select”action拉起应用选择框，并在自定义字段parameters内声明一个完整的want作为第2层，其中声明传递给被分享方的数据。

```
import wantConstant from '@ohos.ability.wantConstant';

// let path = ...
// let fileFd = ...
// let fileSize = ...
let want = {
    // This action is used to implicitly match the application selctor.
    action: wantConstant.Action.ACTION_SELECT,
    // This is the custom parameter in the first layer of want
    // which is intended to add info to application selector.
    parameters: {
        // The MIME type of pdf
        "ability.picker.type": "application/pdf",
        "ability.picker.fileNames": [path],
        "ability.picker.fileSizes": [fileSize],
        // This a nested want which will be directly send to the user selected application.         
        "ability.want.params.INTENT": {
            "action": "ohos.want.action.sendData",
            "type": "application/pdf",
            "parameters": {
               "keyFd": {"type": "FD", "value": fileFd}
            }
        }
    }
}
```

   以上代码中使用Want自定义字段paramters，其中第一层paramters中的“ability.picker.*”字段用于传递展示信息给应用选择器，具体字段表示为：

   * "ability.picker.type"：应用选择器根据该字段渲染相应的文件类型图标。
   * "ability.picker.fileNames"：应用选择器根据该字段展示文件名。
   * "ability.picker.fileSizes"：应用选择器根据该字段展示文件大小。以字节为单位。
   * "ability.picker.fileNames"与"ability.picker.fileSizes"为数组，其有一一对应关系。

   例如：当"ability.picker.type"为“application/pdf”，"ability.picker.fileNames"为“["接口文档.pdf"]”，"ability.picker.fileSizes"为“[350 * 1024]”时，应用选择器将以下形式展示。
   ![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183826.18703213326048655189580200293418:50001231000000:2800:3D6415035EBB311B15522EBE51372BDCA4263ECAB075303B6D43D0898F1D1102.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)
   示例代码中“ability.want.params.INTENT”字段是一个嵌套Want，内部所含action、type等字段将由应用选择器进行隐式匹配，具体隐式匹配规则可参考[隐式Want匹配原理详解](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/explicit-implicit-want-mappings-0000001478061453-V3#ZH-CN_TOPIC_0000001523808814__%E9%9A%90%E5%BC%8Fwant%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3)。当用户选择具体应用后，“ability.want.params.INTENT”字段的嵌套Want将传递至所选应用。

* 被分享方：
  1. 上文中提到，应用选择器通过“ability.want.params.INTENT”字段进行隐式匹配。因此被分享方Ability配置文件内（stage模型下的module.json5）skills字段需配置如下。

```
"skills": [
  {
    "entities": [
      // ...
    ],
    "actions": [
        "ohos.want.action.sendData"
        // ...
    ],
    "uris": [
      {
        "type": "application/pdf"
      },
      // ...
    ]
  },
]
```

     其中"actions"字段和“uris”内“type”字段分别与“ability.want.params.INTENT”内“action”，“type”字段匹配。

     注意：当前文件传递不支持uri方式传递，仅支持FD方式，但隐式匹配中，Want内的“type”字段需与被分享方配置文件skills内“uris”字段下的“type”字段匹配，因此skills内的“uris”字段建议只声明“type”字段，增加“host”，“port”等字段在上述示例中将匹配失败。因为应用选择框通过“ability.want.params.INTENT”发起隐式匹配，所以在“ability.want.params.INTENT”字段内增加uri字段，且与skills内的“uris”字段匹配时，仍可匹配成功且传递额外数据。
  2. 应用选择器拉起被分享方后，系统将调用其“onCreate”接口，并传入“ability.want.params.INTENT”至其入参want内。

```
onCreate(want, launchParam) {
  // note when keyFd is undefined, app crash will happen.
  if (want["parameters"]["keyFd"] !== undefined) {
    // receive file descriptor
    let fd = want["parameters"]["keyFd"].value;
    // ...
  }
}
```



# 进程模型概述

更新时间: 2024-01-15 11:54

HarmonyOS的进程模型：

* 应用中（同一包名）的所有UIAbility运行在同一个独立进程中。
* WebView拥有独立的渲染进程。

基于HarmonyOS的进程模型，系统提供了[公共事件机制](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/common-event-overview-0000001427744568-V3)用于一对多的通信场景，公共事件发布者可能存在多个订阅者同时接收事件。



# 公共事件简介

更新时间: 2024-01-15 12:17

HarmonyOS通过CES（Common Event Service，公共事件服务）为应用程序提供订阅、发布、退订公共事件的能力。

公共事件从系统角度可分为：系统公共事件和自定义公共事件。

* 系统公共事件：CES内部定义的公共事件，只有系统应用和系统服务才能发布，例如HAP安装，更新，卸载等公共事件。目前支持的系统公共事件详见[系统公共事件定义](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/commoneventmanager-definitions-0000001493424344-V3)。
* 自定义公共事件：应用自定义一些公共事件用来实现跨进程的事件通信能力。

公共事件按发送方式可分为：无序公共事件、有序公共事件和粘性公共事件。

* 无序公共事件：CES转发公共事件时，不考虑订阅者是否接收到，且订阅者接收到的顺序与其订阅顺序无关。
* 有序公共事件：CES转发公共事件时，根据订阅者设置的优先级等级，优先将公共事件发送给优先级较高的订阅者，等待其成功接收该公共事件之后再将事件发送给优先级较低的订阅者。如果有多个订阅者具有相同的优先级，则他们将随机接收到公共事件。
* 粘性公共事件：能够让订阅者收到在订阅前已经发送的公共事件就是粘性公共事件。普通的公共事件只能在订阅后发送才能收到，而粘性公共事件的特殊性就是可以先发送后订阅。发送粘性事件必须是系统应用或系统服务，且需要申请ohos.permission.COMMONEVENT_STICKY权限，配置方式请参阅[访问控制授权申请指导](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/accesstoken-guidelines-0000001493744016-V3#ZH-CN_TOPIC_0000001574088333__stage%E6%A8%A1%E5%9E%8B)。

每个应用都可以按需订阅公共事件，订阅成功，当公共事件发布时，系统会将其发送给对应的应用。这些公共事件可能来自系统、其他应用和应用自身。

图1 公共事件示意图

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240103115012.44536390775276881684360472468542:50001231000000:2800:92B9D2C9ABA98B9CAA382490A39F880D50740D784A686E40F4A0145BB9EB6336.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)



# 公共事件订阅概述

更新时间: 2024-01-15 11:54

公共事件服务提供了动态订阅和静态订阅两种订阅方式。动态订阅与静态订阅最大的区别在于，动态订阅是应用运行时行为，而静态订阅是后台服务无需处于运行状态。

* 动态订阅：指订阅方在运行时调用公共事件订阅的API实现对公共事件的订阅，详见[动态订阅公共事件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/common-event-subscription-0000001544583897-V3)。
* 静态订阅：订阅方通过配置文件声明和实现继承自StaticSubscriberExtensionAbility的类实现对公共事件的订阅，详见[静态订阅公共事件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/common-event-static-subscription-0000001544703825-V3)。



# 动态订阅公共事件

更新时间: 2024-01-15 11:54

## 场景介绍

动态订阅是指当应用在运行状态时对某个公共事件进行订阅，在运行期间如果有订阅的事件发布那么订阅了这个事件的应用将会收到该事件及其传递的参数。例如，某应用希望在其运行期间收到电量过低的事件，并根据该事件降低其运行功耗，那么该应用便可动态订阅电量过低事件，收到该事件后关闭一些非必要的任务来降低功耗。订阅部分系统公共事件需要先[申请权限](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/accesstoken-guidelines-0000001493744016-V3)，订阅这些事件所需要的权限请见[公共事件权限列表](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commoneventmanager-0000001427902640-V3#ZH-CN_TOPIC_0000001574088313__support)。

## 接口说明

详细接口见[接口文档](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commonevent-0000001478181597-V3#ZH-CN_TOPIC_0000001523648890__commoneventcreatesubscriber)。

| 接口名                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 接口描述                 |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------- |
| createSubscriber(subscribeInfo:[CommonEventSubscribeInfo](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commoneventmanager-0000001427902640-V3#ZH-CN_TOPIC_0000001574088313__commoneventsubscribeinfo), callback: AsyncCallback[[CommonEventData](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commoneventmanager-0000001427902640-V3#ZH-CN_TOPIC_0000001574088313__commoneventdata)](%5BCommonEventData%5D(https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commoneventmanager-0000001427902640-V3#ZH-CN_TOPIC_0000001574088313__commoneventdata))): void | 创建订阅者对象(callback) |
| createSubscriber(subscribeInfo: CommonEventSubscribeInfo): Promise`<CommonEventSubscriber>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | 创建订阅者对象(promise)  |
| subscribe(subscriber: CommonEventSubscriber, callback: AsyncCallback): void                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 订阅公共事件             |

## 开发步骤

1. 导入模块。

```
import commonEventManager from '@ohos.commonEventManager'; 
import Base from '@ohos.base';
```
2. 创建订阅者信息，详细的订阅者信息数据类型及包含的参数请见[CommonEventSubscribeInfo](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commoneventmanager-0000001427902640-V3#ZH-CN_TOPIC_0000001574088313__commoneventsubscribeinfo)文档介绍。
```
// 用于保存创建成功的订阅者对象，后续使用其完成订阅及退订的动作
let subscriber: commonEventManager.CommonEventSubscriber | null = null;
// 订阅者信息
let subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {
  events: ["usual.event.SCREEN_OFF"], // 订阅灭屏公共事件
}
```
3. 创建订阅者，保存返回的订阅者对象subscriber，用于执行后续的订阅、退订等操作。
```
// 创建订阅者回调
commonEventManager.createSubscriber(subscribeInfo, (err: Base.BusinessError, data: commonEventManager.CommonEventSubscriber) => {
  if (err) {
    console.error(`Failed to create subscriber. Code is ${err.code}, message is ${err.message}`);
    return;
  }
  console.info('Succeeded in creating subscriber.');
  subscriber = data;
  // 订阅公共事件回调
})
```
4. 创建订阅回调函数，订阅回调函数会在接收到事件时触发。订阅回调函数返回的data内包含了公共事件的名称、发布者携带的数据等信息，公共事件数据的详细参数和数据类型请见[CommonEventData](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commoneventmanager-0000001427902640-V3#ZH-CN_TOPIC_0000001574088313__commoneventdata)文档介绍。
```
// 订阅公共事件回调
if (subscriber !== null) {
  commonEventManager.subscribe(subscriber, (err: Base.BusinessError, data: commonEventManager.CommonEventData) => {
    if (err) {
      console.error(`Failed to subscribe common event. Code is ${err.code}, message is ${err.message}`);
      return;
    }
  })
} else {
  console.error(`Need create subscriber`);
}
```



# 取消动态订阅公共事件

更新时间: 2024-01-15 11:54

## 场景介绍

动态订阅者完成业务需要时，需要主动取消订阅，订阅者通过调用[unsubscribe()](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commoneventmanager-0000001427902640-V3#ZH-CN_TOPIC_0000001574088313__commoneventmanagerunsubscribe)方法取消订阅事件。

## 接口说明

| 接口名                                                                   | 接口描述         |
| :------------------------------------------------------------------------- | :----------------- |
| unsubscribe(subscriber: CommonEventSubscriber, callback?: AsyncCallback) | 取消订阅公共事件 |

## 开发步骤

1. 导入CommonEvent模块。

```
import commonEvent from '@ohos.commonEventManager';
```

1. 根据[动态订阅公共事件](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/common-event-subscription-0000001544583897-V3)章节的步骤来订阅某个事件。
2. 调用CommonEvent中的unsubscribe方法取消订阅某事件。
```
// subscriber为订阅事件时创建的订阅者对象
if (subscriber !== null) {
    commonEvent.unsubscribe(subscriber, (err) => {
        if (err) {
            console.error(`[CommonEvent] UnsubscribeCallBack err=${JSON.stringify(err)}`)
        } else {
            console.info(`[CommonEvent] Unsubscribe`)
            subscriber = null
        }
    })
}
```



# 公共事件发布

更新时间: 2024-01-15 12:19

## 场景介绍

当需要发布某个自定义公共事件时，可以通过publish()方法发布事件。发布的公共事件可以携带数据，供订阅者解析并进行下一步处理。

注意

已发出的粘性公共事件后来订阅者也可以接收到，其他公共事件都需要先订阅再接收，订阅参考[公共事件订阅章节](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/common-event-subscription-0000001544583897-V3)。

## 接口说明

详细接口见[接口文档](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commonevent-0000001478181597-V3#ZH-CN_TOPIC_0000001523648890__commoneventpublish)。

| 接口名                                                                                                                                                                                                                                                      | 接口描述                     |
| :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------- |
| publish(event: string, callback: AsyncCallback)                                                                                                                                                                                                             | 发布公共事件。               |
| publish(event: string, options:[CommonEventPublishData](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commoneventmanager-0000001427902640-V3#ZH-CN_TOPIC_0000001574088313__commoneventpublishdata), callback: AsyncCallback) | 指定发布信息并发布公共事件。 |

## 发布不携带信息的公共事件

不携带信息的公共事件，只能发布无序公共事件。

1. 导入CommonEvent模块。
```
import commonEvent from '@ohos.commonEventManager';
```
2. 传入需要发布的事件名称和回调函数，发布事件。
```
// 发布公共事件
commonEvent.publish("usual.event.SCREEN_OFF", (err) => {
    if (err) {
        console.error(`[CommonEvent] PublishCallBack err=${JSON.stringify(err)}`);
    } else {
        console.info(`[CommonEvent] Publish success`);
    }
})
```

## 发布携带信息的公共事件

携带信息的公共事件，可以发布为无序公共事件、有序公共事件和粘性事件，可以通过参数[CommonEventPublishData](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-commoneventmanager-0000001427902640-V3#ZH-CN_TOPIC_0000001574088313__commoneventpublishdata)的isOrdered、isSticky的字段进行设置。

1. 导入CommonEvent模块。
```
import commonEvent from '@ohos.commonEventManager';
```
2. 传入需要发布的事件名称和回调函数，发布事件。
```
// 公共事件相关信息
let options = {
    code: 1, // 公共事件的初始代码
    data: "initial data", // 公共事件的初始数据
}
```
3. 传入需要发布的事件名称、需要发布的指定信息和回调函数，发布事件。
```
// 发布公共事件
commonEventManager.publish("custom_event", options, (err) => {
    if (err) {
        console.error('[CommonEvent] PublishCallBack err=' + JSON.stringify(err));
    } else {
        console.info('[CommonEvent] Publish success')
    }
})
```



# 线程模型概述

更新时间: 2024-01-15 12:17

HarmonyOS应用中每个进程都会有一个主线程，主线程有如下职责：

1. 执行UI绘制；
2. 管理主线程的ArkTS引擎实例，使多个UIAbility组件能够运行在其之上；
3. 管理其他线程（例如Worker线程）的ArkTS引擎实例，例如启动和终止其他线程；
4. 分发交互事件；
5. 处理应用代码的回调，包括事件处理和生命周期管理；
6. 接收Worker线程发送的消息；

除主线程外，还有一类与主线程并行的独立线程Worker，主要用于执行耗时操作，但不可以直接操作UI。Worker线程在主线程中创建，与主线程相互独立。最多可以创建8个Worker：

![](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20231121183829.84284400967280132653406303838080:50001231000000:2800:BE3E57C2B4D0144FDD76F3AB5F35C39C7F791AB7A3191D8E8433E58B105B04F8.png?needInitFileName=true?needInitFileName=true?needInitFileName=true?needInitFileName=true)

基于HarmonyOS的线程模型，不同的业务功能运行在不同的线程上，业务功能的交互就需要线程间通信。线程间通信目前主要有Emitter和Worker两种方式，其中Emitter主要适用于线程间的事件同步， Worker主要用于新开一个线程执行耗时任务。

说明：

* Stage模型只提供了主线程和Worker线程，Emitter主要用于主线程内或者主线程和Worker线程的事件同步。



# 使用Emitter进行线程间通信

更新时间: 2024-01-15 11:54

[Emitter](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-emitter-0000001428061916-V3)主要提供线程间发送和处理事件的能力，包括对持续订阅事件或单次订阅事件的处理、取消订阅事件、发送事件到事件队列等。

Emitter的开发步骤如下：

1. 订阅事件
```
import emitter from "@ohos.events.emitter";

// 定义一个eventId为1的事件
let event = {
    eventId: 1
};

// 收到eventId为1的事件后执行该回调
let callback = (eventData) => {
    console.info('event callback');
};

// 订阅eventId为1的事件
emitter.on(event, callback);
```
2. 发送事件
```
import emitter from "@ohos.events.emitter";

// 定义一个eventId为1的事件，事件优先级为Low
let event = {
    eventId: 1,
    priority: emitter.EventPriority.LOW
};

let eventData = {
    data: {
        "content": "c",
        "id": 1,
        "isEmpty": false,
    }
};

// 发送eventId为1的事件，事件内容为eventData
emitter.emit(event, eventData);
```



# 使用Worker进行线程间通信

更新时间: 2024-01-15 11:54

[Worker](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-worker-0000001427902752-V3)是与主线程并行的独立线程。创建Worker的线程被称为宿主线程，Worker工作的线程被称为Worker线程。创建Worker时传入的脚本文件在Worker线程中执行，通常在Worker线程中处理耗时的操作，需要注意的是，Worker中不能直接更新Page。

Worker的开发步骤如下：

1. 在工程的[模块级build-profile.json5](https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ohos-building-configuration-0000001218440654#section6887184182020)文件的buildOption属性中添加配置信息。
```
  "buildOption": {
    "sourceOption": {
      "workers": [
        "./src/main/ets/workers/worker.ts"
      ]
    }
  }
```
2. 根据build-profile.json5中的配置创建对应的worker.ts文件。
```
import worker from '@ohos.worker';

let parent = worker.workerPort;

// 处理来自主线程的消息
parent.onmessage = function(message) {
    console.info("onmessage: " + message)
    // 发送消息到主线程
    parent.postMessage("message from worker thread.")
}
```
3. 主线程中使用如下方式初始化和使用worker。
   * Stage模型：
```
import worker from '@ohos.worker';

let wk = new worker.ThreadWorker("entry/ets/workers/worker.ts");

// 发送消息到worker线程
wk.postMessage("message from main thread.")

// 处理来自worker线程的消息
wk.onmessage = function(message) {
    console.info("message from worker: " + message)

    // 根据业务按需停止worker线程
    wk.terminate()
}
```
   * FA模型：
```
import worker from '@ohos.worker';

let wk = new worker.ThreadWorker("../workers/worker.ts");

// 发送消息到worker线程
wk.postMessage("message from main thread.")

// 处理来自worker线程的消息
wk.onmessage = function(message) {
    console.info("message from worker: " + message)

    // 根据业务按需停止worker线程
    wk.terminate()
}
```

说明：

* build-profile.json5中配置的worker.ts的相对路径都为./src/main/ets/workers/worker.ts时，在Stage模型下创建worker需要传入路径entry/ets/workers/worker.ts；在FA模型下创建worker需要传入路径../workers/worker.ts。
* 主线程与Worker线程间支持的数据类型参考[序列化支持类型](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-worker-0000001427902752-V3#ZH-CN_TOPIC_0000001574088505__%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%AF%E6%8C%81%E7%B1%BB%E5%9E%8B)。



